<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>MySQL on imxiejie</title>
        <link>https://www.imxiejie.me/categories/mysql/</link>
        <description>Recent content in MySQL on imxiejie</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Sat, 11 Feb 2023 21:02:47 +0800</lastBuildDate><atom:link href="https://www.imxiejie.me/categories/mysql/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>MySQL 学习笔记</title>
        <link>https://www.imxiejie.me/p/mysql-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Sat, 11 Feb 2023 21:02:47 +0800</pubDate>
        
        <guid>https://www.imxiejie.me/p/mysql-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h3 id=&#34;一mysql-架构&#34;&gt;一、MySQL 架构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://www.imxiejie.me/p/mysql-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/mysql1-1.png&#34;
	width=&#34;2924&#34;
	height=&#34;1396&#34;
	srcset=&#34;https://www.imxiejie.me/p/mysql-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/mysql1-1_hu6b069053f013a35665095838b2d46494_518521_480x0_resize_box_3.png 480w, https://www.imxiejie.me/p/mysql-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/mysql1-1_hu6b069053f013a35665095838b2d46494_518521_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;mysql 1-1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;209&#34;
		data-flex-basis=&#34;502px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;二隔离级别&#34;&gt;二、隔离级别&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;READ UNCOMMITTED （未提交读）&lt;/strong&gt;&lt;br&gt;
在 READ UNCOMMITTED
隔离级别下，事务中的修改，即使么有提交，对其他事务都是可见的。事务可以读取未提交的数据，这被称为
&lt;strong&gt;脏读&lt;/strong&gt;。该隔离级别在实际中很少使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;READ COMMITTED（提交读）&lt;/strong&gt;&lt;br&gt;
在 READ COMMITTED
下，一个事务开始时，只能“看见”已经提交的修改。一个事务在提交之前，所做的任何修改对其他事务都是不可见的。但这个级别也被称为 &lt;strong&gt;不可重复读&lt;/strong&gt;，因为两次执行相同的查询，得到的结果可能是不一样的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;REPEATABLE READ（可重复读）&lt;/strong&gt;&lt;br&gt;
在 REPEATABLE READ
下，事务多次读取同样的记录，结果是一致的。但在理论上，可重复读无法解决另一个
&lt;strong&gt;幻读&lt;/strong&gt;
的问题。所谓幻读，指的是当某个事务在读取某个范围内的数据时，另外一个事务在该范围内插入了新的数据，当之前的事务再次读取该范围时，会产生
&lt;strong&gt;幻行&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;InnoDB 通过多版本并发控制（MVCC）解决幻读问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;SERIALIZABLE（串行化）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SERIALIZABLE
是最高的隔离级别，在该级别下，所有事务都被强制串行执行，避免了幻读问题。简单来说，SERIALIZABLE
会讲读取的每一行数据上都加上锁，所以可能导致大量的超时和锁争用问题。实际中很少使用该隔离级别。
&lt;img src=&#34;https://www.imxiejie.me/p/mysql-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/mysql1-2.png&#34;
	width=&#34;2478&#34;
	height=&#34;710&#34;
	srcset=&#34;https://www.imxiejie.me/p/mysql-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/mysql1-2_hue3247d087a1875f4dc4cfda2f67a198f_159973_480x0_resize_box_3.png 480w, https://www.imxiejie.me/p/mysql-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/mysql1-2_hue3247d087a1875f4dc4cfda2f67a198f_159973_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;mysql1-2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;349&#34;
		data-flex-basis=&#34;837px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;三mvcc-多版本并发控制&#34;&gt;三、MVCC （多版本并发控制）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;MVCC&lt;/strong&gt; 是通过保存数据在某个时间的快照来实现的，典型的有 &lt;strong&gt;乐观并发控制&lt;/strong&gt; 和 &lt;strong&gt;悲观并发控制&lt;/strong&gt; 具体实现根据存储引擎的不同而不同，在这里主要关注 InnoDB。&lt;br&gt;
在 InnoDB 中，MVCC
是通过在行最后添加两个隐藏列来实现的，一个是创建时间，一个是过期时间（或删除时间），当然，这存储的并不是时间值，而是事务版本号，每个事务在开始时都会被分配一个版本号（版本号是递增的）。下面看一下在 &lt;strong&gt;REPEATABLE READ&lt;/strong&gt; 隔离级别下，MVCC 具体是如何操作的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SELECT&lt;/strong&gt;&lt;br&gt;
InnoDB 会根据以下两个条件来检查每行记录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InnoDB
只会查找版本号小于等于当前版本号的数据行，这样可以保证事务读取的行，要么是事务开始前已经存在的，要么是当前事务操作的。&lt;/li&gt;
&lt;li&gt;行的删除版本号要么未定义，要么大于当前事务版本号。这样可以保证事务读取到的行在事务开始前没有被删除。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;INSERT&lt;/strong&gt;&lt;br&gt;
InnoDB 为新插入的每一行保存当前版本号作为行版本号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DELETE&lt;/strong&gt;&lt;br&gt;
InnoDB 为删除的每一行保存当前版本号作为删除标识。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UPDATE&lt;/strong&gt;&lt;br&gt;
InnoDB
为插入一行新纪录，保存当前版本号作为行版本号，同时保存当前版本号作为原来的行的删除标识。&lt;/p&gt;
&lt;p&gt;保存这两个版本号，使得大多数的操作都可以不用加锁。在提升性能的同时，也有不足之处。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作以及一些额外的维护工作。&lt;/p&gt;
&lt;p&gt;MVCC 只在 REPEATABLE READ 和 READ COMMITTED
两个隔离级别下工作。其他两个隔离级别都和 MVCC 不兼容，因为 READ UNCOMMITTED
总是读取最新的行，而 SERIALIZABLE 会对所有读取到的行都加锁。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
