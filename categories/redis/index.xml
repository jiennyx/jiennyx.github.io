<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Redis on imxiejie</title>
        <link>https://www.imxiejie.me/categories/redis/</link>
        <description>Recent content in Redis on imxiejie</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Tue, 07 Mar 2023 17:55:38 +0800</lastBuildDate><atom:link href="https://www.imxiejie.me/categories/redis/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Redis 学习笔记</title>
        <link>https://www.imxiejie.me/p/redis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Tue, 07 Mar 2023 17:55:38 +0800</pubDate>
        
        <guid>https://www.imxiejie.me/p/redis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h3 id=&#34;一redis-为什么快&#34;&gt;一、Redis 为什么快？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Redis 是内存数据库，所有的操作都在内存上完成，内存的访问速度本来就很快。&lt;/li&gt;
&lt;li&gt;Redis 最终是对数据结构进行增删改查，得益于高效的数据结构。&lt;/li&gt;
&lt;li&gt;Redis 是单线程的，避免了多线程的额外开销。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面所提到的第 3 点，Redis 并不是真正的单线程，只是网络 I/O
和键值对读写是由一个线程来完成的，这也是 Redis
工作的主要流程，像其他持久化、异步删除、集群同步等功能是由其他线程来完成的。&lt;/p&gt;
&lt;p&gt;Redis 采用单线程的一个核心原因是为了避免多线程引发的并发控制问题。之所以单线程的
Redis 也能获得高性能，跟多路复用的 I/O 模型密切相关，避免了潜在的网络 I/O
阻塞点。Redis 采用的 epoll
提供了基于事件的回调机制，即针对不同的事件，调用不同的处理函数。&lt;/p&gt;
&lt;p&gt;Redis 基于单线程处理 I/O 请求的性能瓶颈主要在 2 个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;任何一个请求在 server 中一旦发生耗时操作，都会影响整个 server
的性能，也就是说，后面的操作都要等这个请求处理完才能进行处理。耗时操作主要包括以下几种：
&lt;ul&gt;
&lt;li&gt;操作 bigkey。写入或删除一个 bigkey 在内存的操作非常耗时。&lt;/li&gt;
&lt;li&gt;使用复杂度过高的命令。比如 SORT、SUNION 或 O(N) （N 很大）的命令。&lt;/li&gt;
&lt;li&gt;大量的 key 集中过期。Redis 的过期机制是在主线程中执行的，大量 key
集中过期会导致在处理一个请求时，都在删除过期 key。&lt;/li&gt;
&lt;li&gt;淘汰策略。淘汰策略也是在主线程中执行的，当内存超过 Redis
内存上限后，每次写入都要淘汰一些 key，导致耗时边长。&lt;/li&gt;
&lt;li&gt;AOF 刷盘开启 always
机制。每次写入都要写入磁盘，写磁盘速度远比写内存慢，拖慢 Redis 性能。&lt;/li&gt;
&lt;li&gt;主从全量同步生成 RDB。虽然采用 fork 子进程生成快照，但是 fork
这一瞬间也是会阻塞整个线程，实例越大，阻塞越久。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;并发量非常大时，单线程读写客户端 I/O
数据存在性能瓶颈，虽然采用多路复用机制，但是读写客户端数据依旧是同步
I/O（内核缓冲区拷贝数据）。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Redis 6.0 版本提供了多线程，可以再高并发的场景下利用 CPU 多核多线程读写客户端数据，但每个命令的操作仍旧是单线程的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;二redis-的键值对存储&#34;&gt;二、Redis 的键值对存储&lt;/h3&gt;
&lt;p&gt;Redis
通过一个全局哈希表来存储键值对，一个哈希表就是一个数组，哈希桶中存储的不是值本身，而是指向值的指针，故
Redis 的多种数据类型都可以用 1 个 entry 来表示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.imxiejie.me/p/redis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redis1-1.webp&#34;
	width=&#34;1773&#34;
	height=&#34;875&#34;
	srcset=&#34;https://www.imxiejie.me/p/redis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redis1-1_hue3c2c2e095accee6b5ade4f0d724f1ba_66618_480x0_resize_q75_h2_box_2.webp 480w, https://www.imxiejie.me/p/redis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redis1-1_hue3c2c2e095accee6b5ade4f0d724f1ba_66618_1024x0_resize_q75_h2_box_2.webp 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;202&#34;
		data-flex-basis=&#34;486px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;用哈希表存储必然会出现哈希冲突，而 Redis 解决哈希冲突的方式是使用
&lt;em&gt;链地址法&lt;/em&gt;，即 entry 还要包括指向下一节点的指针，当同一哈希桶内的 entry
多了以后，查找效率势必会降低，Redis 会采用 rehash 操作，Redis
维护了两个全局哈希表，一开始，默认使用 哈希表 1，随着数据增多，Redis 开始执行
rehash：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为哈希表 2 分配更多的空间，比如为哈希表 1 的两倍&lt;/li&gt;
&lt;li&gt;将哈希表 1 的数据重新映射到哈希表 2&lt;/li&gt;
&lt;li&gt;释放哈希表 1 的空间&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至此，就可以从哈希表 1 切换到哈希表 2，而原来的哈希表 1 留着下次扩容备用。&lt;/p&gt;
&lt;p&gt;一次性拷贝大量的数据会造成线程阻塞，为了避免这个问题，Redis 采用的是渐进式
rehash，Redis
仍然正常处理客户端请求，而在每次处理请求时，从第一个索引位置，将这个索引上的数据拷贝到哈希表
2 中。除了处理请求时会进行 rehash，后台也有一个定时任务，隔一段时间进行一次
rehash 操作。&lt;/p&gt;
&lt;h3 id=&#34;三redis-的持久化机制&#34;&gt;三、Redis 的持久化机制&lt;/h3&gt;
&lt;p&gt;Redis 的持久化机制主要依靠 AOF 日志和 RDB 快照。&lt;/p&gt;
&lt;h4 id=&#34;aofappend-only-file-日志&#34;&gt;AOF（Append Only File） 日志&lt;/h4&gt;
&lt;p&gt;AOF 日志中记录的是以文本形式的操作命令，
它是一个写后日志，即先执行命令，后写日志。后写日志的好处是不会阻塞当前的写操作，也不会写入错误的命令。&lt;/p&gt;
&lt;p&gt;不过 AOF
日志也有两个潜在的风险，首先，如果刚执行完一条命令，日志还没写入就宕机了，那么这条命令就丢失了。其次，AOF
虽然避免了对当前操作的阻塞，但可能会阻塞下一条命令，因为 AOF
日志也是在主线程中执行的。如果磁盘写压力很大，那么后续的命令也就无法执行了。&lt;/p&gt;
&lt;p&gt;这两个风险都跟写回的磁盘的时机有关，Redis 给 AOF 提供了三种写回时机：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Always。同步写回，每次执行完命令就写回磁盘。&lt;/li&gt;
&lt;li&gt;Everysec。每秒写回。每次执行完写命令，就把命令写到 AOF
的内存缓冲区，每隔一秒写回磁盘。&lt;/li&gt;
&lt;li&gt;No。由操作系统控制写回。每次执行完写命令，只写到内存缓冲区，由操作系统来决定何时写回磁盘。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实际需要根据系统对高性能和高可靠性的要求，选择不同的写回策略。&lt;/p&gt;
&lt;p&gt;即使有了 AOF
日志，但是这个日志越来越大怎么办？ 同时也带来了几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文件系统对文件有大小限制，无法保存过大的文件。&lt;/li&gt;
&lt;li&gt;文件越大，写入的效率就越低。&lt;/li&gt;
&lt;li&gt;如果发生了宕机，那么恢复数据库的时间就越长。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Redis 对此提供了 AOF 重写机制，在重写时，Redis 会创建一个新的 AOF 文件，对旧 AOF
文件中的命令进行合并，即对一个 key
的多次操作，只保留最后一次操作的结果。同时，重写 AOF 与 AOF
写回磁盘不同，不会阻塞主线程，重写过程是由主线程 fork 出的后台进程完成的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.imxiejie.me/p/redis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redis4-1.webp&#34;
	width=&#34;3688&#34;
	height=&#34;1920&#34;
	srcset=&#34;https://www.imxiejie.me/p/redis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redis4-1_hu770a5760f103463163111e0b7f90cec5_83552_480x0_resize_q75_h2_box_2.webp 480w, https://www.imxiejie.me/p/redis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redis4-1_hu770a5760f103463163111e0b7f90cec5_83552_1024x0_resize_q75_h2_box_2.webp 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;192&#34;
		data-flex-basis=&#34;461px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;rdbredis-database-快照&#34;&gt;RDB（Redis DataBase） 快照&lt;/h4&gt;
&lt;p&gt;RDB 是内存快照，即内存中数据在某一时刻的状态。与 AOF 相比，RDB
记录的是某一时刻的状态，所以在恢复数据时，可以直接把 RDB 文件读入内存。&lt;br&gt;
Redis 提供了两种方式来生成 RDB 文件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;save。在主线程执行，会导致阻塞。&lt;/li&gt;
&lt;li&gt;bgsave。fork 一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，也是
Redis 的默认配置。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了保持数据的完整性和不影响主线程，采用了写时复制技术，在执行快照的同时，正常进行写操作。
basave 进程是由主线程 fork
出来的，可以共享内存数据，对于需要修改的数据，会被复制一份副本，主线程在这个副本上进行操作，同时，bgsave
子进程可以继续吧原来的数据写入 RDB 文件中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.imxiejie.me/p/redis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redis5-1.jpeg&#34;
	width=&#34;13333&#34;
	height=&#34;7500&#34;
	srcset=&#34;https://www.imxiejie.me/p/redis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redis5-1_hue3ced5d4030d4798a04e7f97568a1313_1150077_480x0_resize_q75_box.jpeg 480w, https://www.imxiejie.me/p/redis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redis5-1_hue3ced5d4030d4798a04e7f97568a1313_1150077_1024x0_resize_q75_box.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;177&#34;
		data-flex-basis=&#34;426px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;虽然采用了写时复制，但是频繁进行 RDB 是不能接受的，推荐采用混合使用 AOF 日志和 RDB 快照，RDB 以一定频率执行，在两次 RDB 之间，通过
AOF 记录这中间的所有写操作。&lt;/p&gt;
&lt;h3 id=&#34;四主从同步&#34;&gt;四、主从同步&lt;/h3&gt;
&lt;p&gt;Redis 采用了主从库模式，以保证数据副本的一致性，主从库之间采用的是读写分离：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读操作。主库、从库都可以接收。&lt;/li&gt;
&lt;li&gt;写操作。只有主库可以接收，然后，主库将写操作同步给从库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;第一次同步&#34;&gt;第一次同步&lt;/h4&gt;
&lt;p&gt;当启动多个 Redis 实例时，就可以通过 replicaof
命令建立主从库关系，接着通过三个阶段完成第一次同步。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.imxiejie.me/p/redis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redis6-1.webp&#34;
	width=&#34;3765&#34;
	height=&#34;1676&#34;
	srcset=&#34;https://www.imxiejie.me/p/redis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redis6-1_hu5516a1ecb422c7081238af236165009f_93892_480x0_resize_q75_h2_box_2.webp 480w, https://www.imxiejie.me/p/redis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redis6-1_hu5516a1ecb422c7081238af236165009f_93892_1024x0_resize_q75_h2_box_2.webp 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;224&#34;
		data-flex-basis=&#34;539px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;第一个阶段是建立连接、协商同步的过程，主要是为同步做准备。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;runID。每个 Redis 实例每次启动时都会有一个随机
ID，用于标识实例。第一次同步不知道主库 ID，故设为 &lt;code&gt;?&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;offset。设为 -1，表示第一次复制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二个阶段，主库将所有数据同步给从库，从库收到数据后，在本地完成数据加载。&lt;/p&gt;
&lt;p&gt;第三个阶段，由于在生成 RDB 文件时，可能会有新的写操作，这些写操作都被写入了
replication buffer，这些写操作会被发送给从库。&lt;/p&gt;
&lt;h4 id=&#34;主从级联模式&#34;&gt;主从级联模式&lt;/h4&gt;
&lt;p&gt;同步有两个主要的耗时操作：生成 RDB 文件和传输 RDB 文件。当有很多从库都要跟主库进行同步时，就会导致主库忙于 fork 子进程进行全量同步。故 Redis
采用了 &lt;code&gt;主-从-从&lt;/code&gt;
模式，将这个耗时操作分散到从库身上，这样其他从库就不用跟主库进行同步，只要跟指定的级联从库进行同步，减轻主库压力。&lt;/p&gt;
&lt;h4 id=&#34;基于长连接的复制&#34;&gt;基于长连接的复制&lt;/h4&gt;
&lt;p&gt;在完成第一次复制后，主从库之间就会维持一个长连接，将后续的写操作同步给从库，可以避免频繁建立连接的开销。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么同步不使用 AOF 而使用 RDB？&lt;/p&gt;
&lt;p&gt;1.RDB 内容是经过压缩的二进制数据，文件很小。而 AOF
记录的是每次的写操作的命令，存在很多冗余的操作。在恢复时，AOF
需要重新执行命令，耗时要比 RDB 多。&lt;/p&gt;
&lt;p&gt;2.利用 AOF 进行同步就意味着要打开 AOF 功能，而打开 AOF
功能就必须要选择刷盘策略，如果选择不当就会严重影响 Redis 性能。而 RDB
只有在需要定时备份或者需要全量同步时才会生成一次快照。在很多丢失数据不敏感的场景，其实不需要开启
AOF 功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;五哨兵机制&#34;&gt;五、哨兵机制&lt;/h3&gt;
&lt;p&gt;在主从库模式下，如果主库挂了，那么就会导致主从库同步，也会影响写操作。那我们就必须要选出一个新主库。&lt;/p&gt;
&lt;p&gt;Redis 采用了哨兵机制来解决主库选举问题，哨兵就是运行在特殊模式下 Redis
进程，主要负责三个任务：监控、选主和通知。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监控。哨兵会定时给所有主从库发送 PING
命令，以检测他们是否正常运行，如果主库没有在规定时间内响应，那么就会判定为主库下线。&lt;/li&gt;
&lt;li&gt;选主。在判定主库下线后，哨兵会按照一定规则从所有从库中选出一个新主库。&lt;/li&gt;
&lt;li&gt;通知。在选出新主库后，哨兵会把新主库的信息发送给其他从库，让它们重新执行
replicaof
命令，建立主从关系。同时，会把新主库的信息通知给客户端，让客户端把请求发送到新主库上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后，在监控中，可能会有多个因素影响下线的判断，比如网络延迟等，单个哨兵只能是“主观下线”，这时需要建立哨兵集群，就像少数服从多数。当多个哨兵认为主库下线后，才能被判定为“客观下线”。
当判定“客观下线”后，哨兵集群会选出一个“哨兵领导者”，由它来进行主从切换。&lt;/p&gt;
&lt;p&gt;在哨兵进行重新选主的过程中，对于客户端的读操作，还是可以在从库执行，但是对于写操作，由于还没有选出新的主库，那么在这期间的写请求都会失败。如果不想让业务感知到异常，客户端就要把写操作先缓存起来或写入消息队列中，等哨兵完成主从切换后，再把这些请求发送给新主库。
所以，客户端在访问主从库时，不能对地址进行写死，而要从哨兵集群中获取最新的地址。&lt;/p&gt;
&lt;h3 id=&#34;六切片集群&#34;&gt;六、切片集群&lt;/h3&gt;
&lt;p&gt;切片集群，指启动多个 Redis
实例组成一个集群，按照一定的规则，把数据分成多份，每一个实例存储一份数据。&lt;/p&gt;
&lt;p&gt;如何找到某个 key 在哪个实例上？&lt;br&gt;
切片集群是一个通用机制，Redis 提供了一个 Redis Cluster
的方案用于实现切片集群。Redis Cluster
采用了哈希槽的方式来处理数据跟实例之间的映射关系，在 Redis Cluster
中，一个切片集群共有 16384 个哈希槽，每个键值对都会根据它的
key，通过 CRC16 计算，对应其中的一个哈希槽。而哈希槽可以根据实例具体情况对其进行手动分配，进行手动分配时，需要把
16384 个哈希槽都分配完，否则无法正常进行工作。&lt;/p&gt;
&lt;p&gt;最初每个实例都只知道自己的哈希槽，在互相建立连接后，它们就会共享自己的哈希槽数据。客户端收到哈希槽信息后，就可以通过计算 key 所处的哈希槽，将请求发送给对应实例。
但哈希槽跟实例的关系不是一成不变的，最常见的变化有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在集群中，实例有新增或删除，那么需要重新分配哈希槽。&lt;/li&gt;
&lt;li&gt;为了负载均衡，Redis 需要重新分布哈希槽。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当发生变化后，客户端是无感知的，这时如果发送了一个请求到旧的实例上，Redis
提供了一种重定向机制，实例会把最新的实例地址发送给客户端，客户端就可以拿着这个新地址重新发送请求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么不直接映射 key 跟实例的关系？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;key 的数量是无法预估的，需要维护大量的 key
跟实例的关系，不管在客户端还是服务端都需要占用非常大的空间。&lt;/li&gt;
&lt;li&gt;当需要重新映射时，映射关系的维护成本过高。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;CRC16 是 16 个 bit，为什么槽最大是 16384？&lt;/p&gt;
&lt;p&gt;在 Redis
发送心跳包时需要把所有的槽放入这个心跳包里，以便让节点知道当前的集群信息，如果槽位最大为
65536，发送心跳包的消息头太大，浪费带宽。另外 Redis 集群节点数基本不会超过
1000 个，对于 1000 个节点，16384 个槽位已经够用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考资料：极客时间《《Redis 核心技术与实战》》&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
