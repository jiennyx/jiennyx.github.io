[{"content":"一、终端登录 在早期的 UNIX 系统中，用户用 哑终端 进行登录，即用硬连接链接到主机。终端可以是本地的（直接连接）也可以是远程的（通过调制解调器连接）。在这两种情况下，登录都经由内核内的终端设备驱动程序。因为连接到主机上的终端设备数是固定的，所以同时的登录数也就有了上限。\n以 BSD 终端登录为例 系统管理者创建名通常为 /etc/ttys 的文件，其中，每个终端设备都有一行，每一行说明设备名和传到 getty 程序的参数。当系统自举时，内核创建进程 ID 为 1 的进程，也就是 init 进程，init 进程使系统进入多用户模式。init 进程读取 /etc/ttys 文件，对每个允许登录的终端设备，init 进程调用一次 fork，它所生成的子进程则 exec getty 程序。\n如下图 9-1 所示，其中所有进程的实际用户 ID 和有效用户 ID 都是 0，即它们都具有超级用户权限，init 以空环境 exec getty 程序。getty 对终端设备调用 open 函数，以读、写方式将终端打开。一旦设备被打开，则文件描述符 0、1、2 就被设备到该设备，随后 getty 输出 \u0026quot;login: \u0026quot; 之类的信息，当用户输入了用户名后，getty 的工作就完成了，随后它开始调用 login 程序。 如上图 9-2 所示，login 得到了用户名后，能够调用 getpawnam 获取相应用户的口令文件登录项，然后调用 getpass 以显示提示 \u0026quot;Password: \u0026quot;，在用户输入完口令后，它调用 crypt 将用户输入的口令加密，并与该用户在阴影口令文件中的登录项 pw_passwd 进行比较。如果用户几次输入的口令无都无效，则 login 以参数 1 调用 exit 表示登录过程失败。父进程即 init 进程了解到子进程的终止情况后，将再次调用 fork ，其后又执行 getty，对此终端重复上述过程。\n如果用户正确登录，login 将完成以下工作：\n将当前工作目录修改为该用户的起始目录。 调用 chown 修改该终端的所有权，使登录用户成为它的所有者。 将对该终端设备的访问权限修改为 用户都和写。 调用 setgid 及 initgroups 设置进程的组 ID。 用 login 得到的所哟欧信息初始化环境：起始目录、shell、用户名以及一个系统默认路径（PATH）。 login 进程更改为登录用户的用户 ID 并调用该用户的登录 shell。 当然，login 所做的事情要比上面说的还要多，至此，登录用户的登录 shell 开始运行，其父进程是 init 进程。所以当 shell 终止时，init 会得到通知，它会对该终端重复上述全部过程，登录 shell 的文件描述符 0、1、2 设置为终端设备。\n至此，shell 将读取启动文件，根据 shell 不同，启动文件也不同。如 .bash_profile 等。当执行完启动文件后，用户最后得到 shell 提示符，并能输入命令。\n二、网络登录 通过串行终端登录和通过网络登录两者之间的主要（物理上）的区别是：网络登录时，在终端和计算机之间的连接不再是点到点的。在网络登录的情况下， login 仅仅是一种可用的服务，这与其他网络服务得性质相同。\n在终端登录中，init 知道有哪些终端设备可用来进行登录，并且为每个设备都生成了一个 getty 进程。但是，在网络登录情况下，所有登录都经由内核的网络接口驱动程序，而且事先并不知道有多少这样的登录。因此必须等待一个网络连接请求的到达，而不是使一个进程等待每一个可能的登录。\n为了使同一个软件既能处理终端登录，又能处理网络登录，系统使用了一种称为 伪终端 的软件驱动程序，它仿真串行终端的运行行为，并将终端操作映射为网络操作，反之亦然。\n以 BSD 网络登录为例 作为系统启动的一部分，init 调用一个 shell，使其执行 shell 脚本 /etc/rc，由此 shell 启动一个守护进程 inetd，它等待大多数网络连接。一旦此 shell 脚本终止，inetd 父进程就变成 init。inetd 等待 TCP/IP 连接，当请求到达时，它执行一次 fork，然后生成的子进程 exec 适当的程序。\n假定一个对于 TELNET 服务进程的 TCP 连接请求到达，如下图所示： 然后，telentd 进程打开一个伪终端设备，并用 fork 分成两个进程。父进程处理通过网络连接的通信，子进程执行 login 程序。父进程和子进程通过伪终端相连接。在调用 exec 之前，子进程使其文件描述符 0、1、2 与伪终端相连接。login 执行与终端登录时相同。\n注意：当通过终端或网络登录时，我们得到一个登录 shell，其标准输入、标准输出和标准错误要么连接到一个终端设备，要么连接到一个伪终端设备上。\n三、进程组 进程组 是一个或多个进程的集合，一个进程除了有一个进程 ID 外，还属于一个进程组。通常，它们是在同一作业中结合起来的，同一进程组中的进程接收来自同一终端的各种信号。每个进程组都有唯一的进程组 ID，进程组 ID 类似于进程 ID，它是一个正整数。\n下列函数可用于返回进程的进程组 ID：\n1 2 3 4 5 6 7 8 9 #include \u0026lt;unistd.h\u0026gt; pid_t getpgrp(void); 返回值：调用进程的进程组 ID pid_t getpgid(pid_t pid); 返回值：若成功，返回进程组 ID；若出错，返回 -1 在 getpgid 种，若 pid 为 0，则返回的是调用进程的进程组 ID，与 getpgrp 相同。\n每个进程组都有一个组长进程，组长进程的进程组 ID 等于其进程 ID。进程组组长可以创建一个进程组、创建该组中的进程，然后终止。只要在某个进程组中有一个进程存在，那么这个进程组就存在，与组长进程是否终止无关。从进程组常见开始到其中最后一个进程离开为止的时间区段叫做进程组的生命期。最后一个进程可以终止，也可以转移到其他进程组。\n下面函数用于创建一个进程组或加入一个进程组：\n1 2 3 4 5 #include \u0026lt;unistd.h\u0026gt; int setpgid(pid_t pid, pid_t pgid); 返回值：若成功，返回 0；若出错，返回 -1 setpgid 将 pid 进程的进程组 ID 设置为 pgid，如果这两个参数相等，则由 pid 指定的进程变成进程组组长。如果 pid 是 0，则使用调用者的进程 ID。如果 pgid 是 0，则由 pid 指定的进程 ID 用作进程组 ID。\n一个进程只能为它自己或它的子进程设置进程组 ID，在它的子进程调用 exec 后，它就不再更改该子进程的进程组 ID。\n在大多数作业控制 shell 中，在 fork 之后调用此函数，使父进程设置其子进程的进程组 ID，并且也使子进程设置其自己的进程组 ID。这两个调用有一个是冗余的，但让父子进程都这样做可以保证，在父进程和子进程认为子进程已经进入该进程组之前，这确实已经发生了。如果不这样做，在 fork 之后，由于父进程和子进程运行的先后次序不确定，会因为子进程的组员身份取决于哪个进程首先执行而产生竞争条件。\n四、会话 会话是一个或多个进程组的集合，如下图所示： 通常是由 shell 的管道将几个进程编成一组。上图可能得命令为：\n1 2 proc1 | proc2 \u0026amp; proc3 | proc4 | proc5 下面的函数可以用于创建一个会话：\n1 2 3 4 5 #include \u0026lt;unistd.h\u0026gt; pid_t setsid(void); 返回值：若成功，返回进程组 ID；若出错，返回 -1 如果调用此函数的不是一个进程组的组长，那么此函数会创建一个新会话。具体会发生以下 3 件事：\n该进程变成会话首进程，此时，该进程是新会话的唯一进程。 该进程变成一个新进程组的组长进程，新进程组 ID 是该调用进程的进程 ID。 该进程没有控制终端，如果在调用 setsid 前有一个控制终端，那么该联系也会被切断。 下面函数用用于获取会话首进程的进程组 ID，即会话 ID：\n1 2 3 4 5 #include \u0026lt;unistd.h\u0026gt; pid_t getsid(pid_t pid); 返回值：若成功，返回会话首进程的进程组 ID；若出错，返回 -1 如果 pid 是 0，getsid 返回调用进程的会话首进程的进程组 ID。出去安全性考虑，如果 pid 不属于调用者所在的会话，那么将无法获得该会话首进程的进程组 ID。\n五、控制终端 会话和进程组还有一些其他特性：\n一个会话可以用一个 控制终端。通常是终端设备或伪终端设备。 建立与控制终端连接的会话首进程叫做 控制进程。 一个会话中的几个进程可以被分为一个 前台进程组 和一个或多个 后台进程组。 如果一个会话有一个控制终端，则它有一个前台进程组，其余进程组为后台进程组。 无论何时键入终端的中断键（即 Ctrl C），都会将中断信号发送给前台进程组的所有进程。 无论何时键入终端的退出键（即 Ctrl \\），都会将退出信号发送给前台进程组的所有进程。 如果终端接口检测到调制解调器（或网络）已经断开连接，则将挂断信号发送至控制进程（即会话首进程）。 这些特性如下图所示： 六、函数 tcgetpgrp、tcsetgprp 和 tcgetsid 需要有一种方法来通知内核哪一个进程组是前台进程组，这样终端设备程序就能知道讲终端输入和终端产生的信号发送至何处。\n1 2 3 4 5 6 7 8 9 #include \u0026lt;unistd.h\u0026gt; pid_t tcgetpgrp(int fd); 返回值：若成功，返回前台进程组 ID；若出错，返回 -1 int tcsetgprp(int fd, pid_t pgrpid); 返回值：若成功，返回 0；若出错，返回 -1 函数 tcgetpgrp 返回前台进程组 ID，它与在 fd 上打开的终端相连接。\n如果进程有一个控制终端，则该进程可以调用 tcsetpgrp 将前台进程组 ID 设置为 pgrpid，pgrpid 应当是在同一会话中的进程进程组 ID，fd 必须引用该会话的控制终端。\n下面的函数可用于获取会话首进程的进程组 ID：\n1 2 3 4 5 #include \u0026lt;termios.h\u0026gt; pid_t tcgetsid(int fd); 返回值：若成功，返回会话首进程的进程组 ID；若出错，返回 -1 七、作业控制 作业：一个作业只是几个进程的集合，通常是一个进程管道。\n作业控制 允许在一个终端上启动多个作业（进程组），它控制哪一个作业可以访问该终端以及哪些作业在后台运行：作业控制要求以下 3 种形式的支持：\n支持作业控制的 shell。 内核中的终端驱动程序必须支持作业控制。 内核必须提供对某种作业控制信号的支持。 只有前台作业接收终端输入。如果后台作业试图读终端，这并不是一个错误，但是终端驱动程序将检测到这种情况，并且向后台作业发送一个特定的信号 SIGTTIN。该信号通常会停止此后台作业，而 shell 则向有关用户发出这种情况的通知，然后用户就可用 shell 命令将此作业转为前台作业运行，于是它就可以读终端。\n具体情况如下： 八、shell 执行程序 无作业控制时，shell fork 一个它自身的副本，然后此副本再为管道中的每条命令 fork 一个进程。管道中的最后一个进程是 shell 的子进程，而执行管道中的其他命令是该最后进程的子进程。 具体情况如下图所示： 注意：使用的 shell 不同，创建各个进程的顺序也可能不同。\n","date":"2023-02-16T11:37:38+08:00","image":"https://www.imxiejie.me/p/%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/unix-book_hu4547a7503b7987387e6e836bc31e69b7_54147_120x120_fill_q75_box_smart1.jpeg","permalink":"https://www.imxiejie.me/p/%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/","title":"进程关系"},{"content":"一、进程标识 每个进程都有一个非负整形表示的唯一进程 ID，虽然进程 ID 是唯一的，但它是可复用的，在进程终止后，其进程 ID 就成为可用的 ID 候选者。但大多数 UNIX 系统都实现了延迟复用算法，使得新进程的进程 ID 不同于最近终止进程所使用的进程 ID，这防止了将新进程认为是使用了某个同一 ID 的已终止进程。\n系统中有些专用进程，比如：\n0 号进程。ID 为 0 的进程通常是调度进程，也被称作 交换进程。该进程是内核的一部分，它不执行磁盘上的程序，因此也被称为 系统进程。 1 号进程。ID 为 1 的进程通常是 init 进程，在自举结束过程时由内核调用。该进程的程序文件是 /sbin/init。该进程负责在自举内核后启动一个 UNIX 系统，init 进程通常读取与系统有关的初始化文件并将系统引导到一个状态（比如多用户）。init 进程绝不会终止，它是一个普通的用户进程，但是它以超级用户特权运行。 注意：根据系统的不同，具体专用进程的实现也不同。\n下面的函数可以返回与进程有关的标识符：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;unistd.h\u0026gt; pid_t getpid(void); 返回值：进程的进程 ID pid_t getppid(void); 返回值：进程的父进程 ID uid_t getuid(void); 返回值：进程的实际用户 ID uid_t geteuid(void); 返回值：进程的有效用户 ID gid_t getgid(void); 返回值：进程的实际组 ID gid_t getegid(void); 返回值：调用进程的有效组 ID 二、函数 fork 一个现有的进程可以调用 fork 函数创建一个新进程：\n1 2 3 4 5 #include \u0026lt;unistd.h\u0026gt; pid_t fork(void); 返回值：若成功，子进程返回 0，父进程返回子进程 ID；若出错，返回 -1 由 fork 创建的新进程称作 子进程。fork 调用一次但返回两次，父进程返回子进程 ID，子进程返回 0。原因是：父进程可以有多个子进程，但没有一个函数可以获取子进程 ID。而一个进程只会有一个父进程，可通过 getppid 函数获取其父进程 ID。\n在 fork 调用完成后，各自继续执行 fork 之后的指令。子进程是父进程的副本。比如：子进程获取父进程数据空间、堆和栈的副本。\n注意：子进程拥有副本，父子进程不共享这些存储空间，父子进程共享正文段。\n由于在 fork 之后经常跟随着 exec，所以现在的很多实现并不执行一个父进程的数据段、堆和栈的完全副本。取而代之的是，使用了 写时复制（Copy-On-Write，COW） 技术。这些区域由父子进程共享，内核把它们的访问权限改为只读。如果父子进程中的一个试图修改这些区域，内核会只为修改区域的那块内存制作一个副本，通过是虚拟存储系统中的一页。\n一般来说，在 fork 之后，父子进程谁先执行是不确定的，取决于内核使用的调度算法。fork 的另外一个特性是，父进程的所有打开文件描述符都会被复制到子进程中，父子进程的每个相同的打开描述符共享一个文件表项。如下图所示： 在 fork 之后处理文件描述符有以下两种常见的情况：\n父进程等待子进程完成。在这种情况下，父进程无需对其描述符做任何的处理，在子进程终止后，它曾读、写过的任一共享描述符的文件表项已经做了更新。 父进程和子进程执行不同的程序段。在这种情况下，在 fork 之后，父子进程会分别关闭它们不需要使用的文件描述符，这样就不会干扰对方使用的描述符。（例如网络服务进程） 除了打开文件外，还有很多属性也由子进程继承，这些属性如下：\n实际用户 ID、实际组 ID、有效用户 ID、有效组 ID。 附属组 ID。 进程组 ID。 会话 ID。 控制终端。 设置用户 ID 标志和设置组 ID 标志。 当前工作目录。 根目录。 文件模式创建屏蔽字。 信号屏蔽和安排。 对任一打开文件描述符执行时关闭标志。 环境。 连接的共享存储段。 存储映像。 资源限制。 父子进程的区别如下：\nfork 的返回值不同。 进程 ID 不同。 各自的父进程 ID 不同。 子进程的 tms_utime、tms_stime、tms_cutime 和 tms_ustime 的值设置为 0。 子进程不继承父进程设置的文件锁。 子进程的未处理闹钟被清除。 子进程的未处理信号集设置为空集。 fork 失败的主要原因有两个：\n系统中已经有了太多的进程。 该实际用户 ID 的进程总数超过了系统限制（CHILD_MAX 规定了每个实际用户 ID 在任何时刻可拥有的最大进程数）。 fork 有以下两种用法：\n一个父进程希望复制自己，使父进程和子进程分别执行不同的代码段，如 Web 服务器。 一个进程要执行一个不同的程序。如 shell，在这种情况下，子进程从 fork 返回之后立即调用 exec。 三、函数 vfork vfork 函数的调用序列和返回值与 fork 相同，但两者语义不同。vfork 函数用于创建一个新进程，而该新进程的目的是执行一个新程序。vfork 和 fork 一样都创建一个子进程，但是它并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用 exec（或 exit），于是也就不会引用到该地址空间。不过在子进程调用 exec 或 exit 前，它会在父进程的空间中运行。\nvfork 和 fork 的另一个区别是：vfork 保证子进程先运行，在它调用 exec 或 exit 之后父进程才可能被调度运行。而如果子进程在调用这两个函数前依赖于父进程的进一步动作，那么将会导致死锁。\n四、函数 exit 回顾一遍进程终止的 5 种正常方式和 3 种异常方式，正常终止：\n在 main 函数内执行 return 语句。 调用 exit 函数。 调用 _exit 或 _Exit 函数。 最后一个线程在其启动例程中执行 return 语句。 最后一个线程调用 pthread_exit 函数。 异常终止：\n调用 abort。 当进程接收到某些信号时。 最后一个线程对取消请求做出响应。 对于上述的任一情形，我们都希望终止进程能够通知其父进程是如何终止的。对于 3 个终止函数，实现这一点的方法是，将其推出状态作为参数传递给函数。在异常终止情况下，内核产生一个指示其终止原因的终止状态。在任一情况下，父进程都可以调用 wait 或 waitpid 函数获取子进程终止状态。\n不管进程如何终止，最后都会执行内核中的同一段代码，这段代码为相应进程关闭所有打开描述符，释放它所使用的存储器等。\n孤儿进程：如果一个父进程在子进程之前终止，那么这个子进程就会变成孤儿进程，init 会收养这些子进程，即这些子进程的父进程会变为 init 进程。操作过程大致是：当一个进程终止时，内核会逐个检查所有活动进程，以判断它是否是将要终止进程的子进程，如果是，则将该进程的父进程 ID 改为 1。\n故一个进程是 init 的子进程时，可能是 init 直接产生的子进程，也可能是被 init 所收养的进程。\n僵死进程：如果子进程完全消失了，父进程在最终准备好检查子进程是否终止时是无法获取其终止状态的。内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用 wait 或 waitpid 时，可以得到这些信息。这些信息至少包含进程 ID、该进程的终止状态以及该进程使用的 CPU 时间总量。内核可以释放终止进程所使用的存储区，关闭其所有打开文件。一个已经终止，但是父进程尚未进程善后处理（即获取终止进程的有关信息，释放它所占用的资源）的进程被称为僵死进程。\n五、函数 wait 和 waitpid 当一个进程终止时，内核就向其父进程发送 SIGCHLD 信号。因为子进程终止是个异步时间，所以这种信号也是内核向父进程发送的异步通知。父进程可以选择忽略该信号，或者提供一个在信号发生时即被调用执行的信号处理函数。\n下面两个函数可用于获取子进程的终止状态：\n1 2 3 4 5 6 7 #include \u0026lt;sys/wait.h\u0026gt; pid_t wait(int *statloc); pid_t waitpid(pid_t pid, int *statloc, int options); 两个函数返回值：若成功，返回进程 ID；若出错，返回 0 或 -1 调用 wait 或 waitpid 可能会发生什么？\n如果所有子进程还在运行，则阻塞。 如果一个子进程已经终止，正等待其父进程获取终止状态，则取得该子进程的终止状态后立即返回。 如果没有任何子进程，则立即出错返回。 这两个函数的区别是：\n在一个子进程终止前，wait 会使调用者阻塞，而 waitpid 有一选项，可以使调用者不阻塞。 waitpid 并不等待其调用后的第一个终止子进程，可以控制它所等待的子进程。 如果子进程已经终止，并且是一个僵死进程，则 wait 立即返回并取得该子进程的状态；否则 wait 将使调用者阻塞，直到一个子进程终止。如果调用者阻塞并且它有多个子进程，那么将在任一个子进程终止时，wait 立即返回。因为 wait 返回进程 ID，故可以知道是哪个子进程终止。\n而 waitpid 根据参数的不同则提供了更加丰富的功能：\npid == -1：等待任一子进程，在这种情况下，和 wait 等效。 pid \u0026gt; 0：等待进程 ID 和 pid 相等的子进程。 pid == 0：等待组 ID 等于调用进程组 ID 的任一子进程。 pid \u0026lt; -1：等待组 ID 等于 pid 绝对值的任一子进程。 六、函数 waitid waitid 同样可以取得进程终止状态：\n1 2 3 4 5 #include \u0026lt;sys/wait.h\u0026gt; int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options); 返回值：若成功，返回 0；若出错，返回 -1 waitid 要更灵活，根据 idtype 的不同：\nP_PID：等待一特定进程：id 包含要等待子进程的进程 ID。 P_PGID：等待一特定进程组中的任一子进程：id 包含要等待子进程的进程组 ID。 P_ALL：等待任一子进程，忽略 ID。 七、函数 wait3 和 wait4 下面两个函数则返回了资源统计信息：\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; #include \u0026lt;sys/time.h\u0026gt; #include \u0026lt;sys/resource.h\u0026gt; pid_t wait3(int *statloc, int options, struct rusage *rusage); pid_t wait4(pid_t pid, int *statloc, int options, struct rusage *rusage); 两个函数返回值：若成功，返回进程 ID；若出错，返回 -1 资源统计信息包括用户 CPU 时间总量、系统 CPU 时间总量、缺页次数、接收到信号的次数等。\n八、竞争条件 当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则认为发生了竞争条件。\n九、函数 exec 当进程调用一种 exec 函数时，该进程执行的程序完全替换为新程序。而新程序则从其 main 函数开始执行。因为调用 exec 并不创建新进程，所以前后的前程 ID 并未改变。exec 只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段。\n下面是 7 个 exec 函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;unistd.h\u0026gt; int execl(const char *pathanme, const char *arg0, ... /* (char *)0 */ ); int execv(const char *pathname, char *const argv[]); int execle(const char *pathname, const char *arg0, ... /* (char *)0, char *const envp[] */ ); int execve(const char *pathname, char *const argv[], char *const envp[]); int execlp(const char *filename, const char *arg0, ... /* (char *)0 */ ); int execvp(const char *filename, char *const argv[]); int fexecve(int fd, char *const argv[], char *const envp[]); 7 个函数返回值：若出错，返回 -1；若成功，不返回 这 7 个函数的区别：\n前 4 个函数取路径名为参数，后两个函数取文件名作为参数，最后一个函数取文件描述符作为参数，当指定 filename 为参数时： 如果 filename 包含 /，则将其视为路径名。 否则就按 PATH 环境变量，在它所指定的各目录中搜寻可执行文件。 PATH 变量包含一张目录表（称为路径前缀），目录之间用冒号 : 分隔。\n第二个区别与参数表的传递有关（l 表示 list，v 表示 vector）。函数 execl、execlp 和 execle 要求将新程序的每个命令行参数都说明为一个单独的参数，以空指针结尾。对于另外 4 个函数，则应先构造一个指向各参数的指针数组，然后将该数组地址作为这 4 个函数的参数。 第三个区别与新程序传递环境表有关。以 e 结尾的 3 个函数（execle、execve 和 fexecve）可以传递一个指向环境字符串指针数组的指针。其他 4 个函数则使用调用进程中的 environ 变量为新程序复制现有的环境。 执行 exec 后，新程序从调用进程继承了以下属性：\n进程 ID 和父进程 ID。 实际用户 ID 和实际组 ID。 附属组 ID。 进程组 ID。 会话 ID。 控制终端。 闹钟尚余留的时间。 当前工作目录。 根目录。 文件模式创建屏蔽字。 文件锁。 进程信号屏蔽。 未处理信号。 资源限制。 友好值（nice 值）。 tms_utime、tms_stime、tms_cutime 以及 tms_cstime 值。 对每个打开文件的处理与每个描述符的执行时关闭（close-on-exec）标志值有关。进程中每个打开描述符都有一个执行时关闭标志，若设置了此标志，则在执行 exec 时关闭描述符；否则该描述符仍打开。\n注意：在 exec 前后，实际用户 ID 和实际组 ID 保持不变，而有效用户 ID 和有效组 ID 则取决于所执行程序文件的设置用户 ID 位和设置组 ID 位是否设置。如果新程序的设置 ID 位已设置，则有效 ID 变为对应的文件所有者 ID。\n这 7 个函数的关系如下图所示： 十、更改用户 ID 和更改组 ID 一般而言，在设计应用时，总是试图使用 最小特权 模型。依照此模型，我们的程序应当只具有未完成给定任务所需的最小特权。（在设计接口时也一样）\n下面的函数可用于修改实际 ID 和有效 ID：\n1 2 3 4 5 6 7 #include \u0026lt;unistd.h\u0026gt; int setuid(uid_t uid); int setgid(gid_t gid); 两个函数返回值：若成功，返回 0；若出错，返回 -1 修改用户 ID 的规则（组 ID 同样适用）：\n若进程拥有超级用户特权，则 setuid 将实际用户 ID、有效用户 ID 以及保存的设置用户 ID 设置为 uid。 若进程没有超级用户特权，但是 uid 等于实际用户 ID 或等于保存的设置用户 ID，则 setuid 只将有效用户 ID 设置为 uid。不更改实际用户 ID 和保存的设置用户 ID。 如果上面两个条件都不满足，则 errno 设置为 EPERM，并返回 -1。 关于内核所维护的 3 个用户 ID，还要注意以下几点：\n只有超级用户进程可以修改实际用户 ID。 仅当对程序文件设置了设置用户 ID 位时，exec 函数才设置有效用户 ID。 保存的设置用户 ID 时由 exec 复制有效用户 ID 得到的。 1. 函数 setreuid 和 setregid 下面两个函数用于交换实际 ID 与有效 ID 的值：\n1 2 3 4 5 6 7 #include \u0026lt;unistd.h\u0026gt; int setreuid(uid_t ruid, uid_t euid); int setregid(gid_t rgid, gid_t egid); 两个函数返回值：若成功，返回 0；若出错，返回 -1 如果其中任一参数的值为 -1，则表示相应的 ID 位应当保持不变。\n交换规则：一个非特权用户总是能交换实际用户 ID 和有效用户 ID。这就允许一个设置用户 ID 程序交换成用户的普通权限，以后又可再次交换回设置用户 ID 权限。POSIX.1 引入了保存的设置用户 ID 后，其规则也相应加强，它允许一个非特权用户将其有效用户 ID 设置为保存的设置用户 ID。\n2. 函数 seteuid 和 setegid 下面两个函数只修改有效用户 ID 和有效组 ID：\n1 2 3 4 5 6 7 #include \u0026lt;unistd.h\u0026gt; int seteuid(uid_t uid); int setegid(gid_t gid); 两个函数返回值：若成功，返回 0；若出错，返回 -1 一个非特权用户可以将其有效用户 ID 设置为其实际用户 ID 或保存的设置用户 ID。对一个特权用户则可将其有效用户 ID 设置为 uid。\n具体规则如下图所示： 3. 组 ID 所有适用于用户 ID 的方式都适用于组 ID，而附属组 ID 不受影响。\n十一、解释器文件 解释器文件 是一个文本文件，其起始行的形式为：\n#! pathname [optional-argument]\n感叹号和 pathname 之间的空格是可选的，具体实例如下：\n#! /bin/sh\npathname 通常是绝对路径名，对它不进行什么特殊处理（不使用 PATH 进行路径搜索），对这种文件的识别是由内核作为 exec 系统调用处理的一部分来完成的。内核使调用 exec 函数的进程实际执行的不是解释器文件，而是在解释器文件中第一行 pathname 所指定的文件。\n十二、函数 system system 函数可用于执行一个命令字符串：\n1 2 3 4 5 #include \u0026lt;stdlib.h\u0026gt; int system(const char *cmdstring); 具体返回值如下： 如果 cmdstring 是一个空指针，则仅当命令处理程序可用时，system 返回非 0 值。\n因为 system 在其实现中调用了 fork、exec 和 waitpid，因此有 3 种返回值：\nfork 失败或 waitpid 返回除 EINTR 之外的错误，则 system 返回 -1，并且设置 errno 以指示错误类型。 如果 exec 失败（表示不能执行 shell），则其返回值如同 shell 执行了 exit(127) 一样。 否则 3 个函数都成功，那么 system 的返回值是 shell 的终止状态。 system 相比较于 fork 和 exec 的优点： system 进行了各种所需的出错处理和信号处理。\n十三、进程会计 大多数 UNIX 系统都会提供一个选项以进行进程会计，启用该选项后，每当进程结束时内核就会写一个会计记录。典型的会计记录包含总量较小的二进制数据，一般包括命令名、所使用的 CPU 时间总量、用户 ID 和组 ID、启动时间等。会计记录结构大致定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 typedef u_short comp_t; /* 3-bit base 8 exponent; 13-bit fraction */ struct acct { char ac_flag; /* flag */ char ac_stat; /* termination status(signal \u0026amp; core flag only) */ uid_t ac_uid; /* real user ID */ gid_t ac_gid; /* real group ID */ dev_t ac_tty; /* controlling terminal */ time_t ac_btime; /* starting calendar time */ comp_t ac_utime; /* user CPU time */ comp_t ac_stime; /* system CPU time */ comp_t ac_etime; /* elapsed time */ comp_t ac_mem; /* average memory usage */ comp_t ac_io; /* bytes transferred (by read and write) */ comp_t ac_rw; /* blocks read or written */ char ac_comm[8]; /* command name */ } 会计记录所需的各个数据都由内核保存在进程表中，并在一个新进程创建时被初始化，在终止时写入会计记录。这将造成两个后果：\n我们不能获取永远不会停止的进程的会计记录。如 init 进程、内核守护进程。 在会计记录文件中的顺序对应于进程终止顺序，而不是它们的启动顺序。 会计记录对应于进程而不是程序。如果一个进程顺序执行了 3 个程序（A exec B、B exec C，最后是 C exit），只会写一个会计记录，在该记录中的命令名对应于程序 C，但 CPU 时间是程序 A、B 和 C 之和。\n十四、用户标识 任何进程都可以得到其实际用户 ID 和有效用户 ID 及组 ID，但是有时候希望可以等到运行该程序的登录名。\n1 2 3 4 5 #include \u0026lt;unistd.h\u0026gt; char *getlogin(void); 返回值：若成功，返回指向登录名字符串的指针；若出错，返回 NULL 十五、进程调度 UNIX 系统历史上对进程提供的只是基于调度优先级的粗粒度的控制，调度策略和调度优先级是由内核确定的。进程可以通过调整友好值选择以更低优先级运行，只有特权进程允许提高调度权限。\n友好值和优先级的关系：友好值越高，优先级越低（越友好，调度优先级就越低）。\n进程可以通过 nice 函数获取或更改它的友好值。使用这个函数，进程只能影响自己的友好值，不能影响其他进程的友好值。\n1 2 3 4 5 #include \u0026lt;unistd.h\u0026gt; int nice(int incr); 返回值：若成功，返回新的友好值 NZERO；若出错，返回 -1 如果 incr 超出合法值界限，系统会调整其至合法值界限。返回 -1，时，需要检查 errno 以确定是否真的出错。\ngetpriority 不仅可以获取进程的友好值，还可以获取一组相关进程的友好值：\n1 2 3 4 5 #include \u0026lt;sys/resource.h\u0026gt; int getpriority(int which, id_t who); 返回值：若成功，返回 -NZERO ~ NZERO - 1 之间的友好值；若出错，返回 -1 which 参数可以是下面三个值之一：PRIO*PROCESS 表示进程，PRIO_PGRP 表示进程组，PRIO_USER 表示用户 ID。如果 which 作用于多个进程，则返回所用作用进程中优先级最高的，即友好值最小的。\nsetpriority 函数可用于设置优先级：\n1 2 3 4 5 #include \u0026lt;sys/resource.h\u0026gt; int setpriority(int which, id_t who, int value); 返回值：若成功，返回 0；若出错，返回 -1 十六、进程时间 times 函数可用于获取墙上时钟时间、用户 CPU 时间和系统 CPU 时间：\n1 2 3 4 5 #include \u0026lt;sys/times.h\u0026gt; clock_t times(struct tms *buf); 返回值：若成功，返回流逝的墙上时钟时间（以时钟滴答数为单位）；若出错，返回 -1 tms 结构具体如下：\n1 2 3 4 5 6 struct tms { clock_t tms_utime /* user CPU time */ clock_t tms_stime /* system CPU time */ clock_t tms_cutime /* user CPU time, terminated children */ clock_t tms_cstime /* system CPU time, terminated children */ } 注意：此结构并没有包含墙上时钟时间，times 函数返回墙上时钟时间作为其函数值。此值是相对于过去的某一时刻度量的，所以不能用其绝对值而必须使用其相对值。两个时间调用两次 times 函数，时间差就是墙上时钟时间。\n","date":"2023-02-15T13:35:27+08:00","image":"https://www.imxiejie.me/p/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/unix-book_hu4547a7503b7987387e6e836bc31e69b7_54147_120x120_fill_q75_box_smart1.jpeg","permalink":"https://www.imxiejie.me/p/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/","title":"进程控制"},{"content":"一、main 函数 C 程序总是从 main 函数开始执行，main 函数的原型是：\nint main(int argc, char *argv[])\n其中，argc 是命令行参数数目，argv 是指向参数的各个指针所构成的数组。\n当内核执行 C 程序时，在调用 main 前会先调用一个启动例程。可执行程序文件将此启动例程作为程序的起始地址\u0026ndash;这是由连接编辑器设置的。而连接编辑器由 C 编译器调用。启动例程从内核中获取命令行参数和环境变量，然后为按上述方式调用 main 函数做好安排。\n二、进程终止 有 8 种方式可以使得进程终止，其中 5 种为正常终止：\n从 main 返回。 调用 exit。 调用 _exit 或 _Exit。 最后一个线程从其启动例程返回。 最后一个线程调用 pthread_exit。 异常终止方式有 3 种：\n调用 abort。 接收到一个信号。 最后一个线程对取消请求做出响应。 启动例程在 main 返回后会立即调用 exit。\n1. 退出函数 有 3 个函数用于正常终止一个程序：\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdlib.h\u0026gt; void exit(int status); void _Exit(int status); #include \u0026lt;unistd.h\u0026gt; void _exit(int status); _exit 和 _Exit 会立即进入内核，而 exit 会先执行一些清理处理（执行一个标准 I/O 的清理关闭操作：对于所有打开流调用 fclose，将所有输出缓冲中的数据冲洗），然后返回内核。\n3 个函数都带一个整形参数，称为 终止状态。如果\n调用这些函数时不带终止状态 或 main 执行了一个无返回值的 return 语句 或 main 没有声明返回类型为整形 则该进程的终止状态是未定义的。但是，如果 main 的返回类型是整形，并且 main 执行到最后一语句时返回（隐式返回），那么该进程的终止状态是 0。\n2. 函数 atexit 一个进程可以登记多至 32 个函数，这些函数将由 exit 自动调用。这些函数被称为 终止处理程序，可以使用 atexit 函数来登记这些函数：\n1 2 3 4 5 #include \u0026lt;stdlib.h\u0026gt; int atexit(void (*func) (void)); 返回值：若成功，返回 0；若出错，返回非 0 exit 调用这些函数的顺序与登记顺序相反，如果一个函数被登记多次，那么也会被调用多次。\n下图展示了一个 C 程序如何启动，以及终止的各种方式： 注意：由图可知，内核使程序执行的唯一方法是调用一个 exec 函数。进程自愿终止的唯一方法是显示或者隐式地调用 _exit 或 _Exit（通过调用 exit）。\n三、命令行参数 当执行一个程序时，调用 exec 的进程可以将命令行参数传递给该新程序（如在 shell 中执行一个新程序）。\n四、环境表 每个程序都有一张 环境表。和参数表一样，环境表也是一个字符指针数组，其中每个指针包含一个以 null 结束的 C 字符串的地址。全局变量 environ 包含了该指针数组的地址：\nextern char **environ 如下图所示，每个字符串结尾都有一个 null 字节，我们称 environ 为 环境指针，指针数组为环境表，其中各指针指向的字符串为 环境字符串。 注意：环境字符串由 name=value 这样的形式组成。\n五、C 程序的存储空间布局 C 程序由以下几个部分组成：\n正文段。这是由 CPU 执行的机器指令部分。通常，正文段是可共享的，另外，正文段常常是只读的，以防止程序由于意外而修改其指令。 初始化数据段。通常将此段称为数据段，它包含了程序中需要明确赋初值的变量。 未初始化数据段。通常将此段称为 bss 段，在程序开始执行前，内核将此段中的数据初始化为 0 或空指针。 堆。通常在堆中进行动态存储分配。 栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。 自动变量：在计算机编程领域，自动变量指的是局部作用域变量，具体来说即是在控制流进入变量作用域时系统自动为其分配存储空间，在并在离开作用域时释放空间的一类变量。自动变量与局部变量所指的变量是同一种变量。\n从图中可以看到，未初始化数据段的内容并不存放在磁盘程序文件中。其原因是，内核在程序开始执行前将它们设置为 0，需要存放在磁盘程序文件中的段只有正文段和初始化数据段。\nsize 命令可以查看正文段、数据段和 bss 段的长度。\n六、共享库 共享库使得可执行文件中不再需要包含公用的库函数，而只需要在所有进程都可引用的存储中保存这种库例程的一个副本。程序第一次执行或第一次调用某个库函数时，用动态链接方法将程序与共享库函数相链接。这样可以减少可执行文件的长度，但增加了一些运行时开销。共享库的另一个优点是可以用库函数的新版本代替老版本而无需对使用该库的程序重新连接编辑（假定参数的数目和类型都没有发生改变）。\n七、存储空间分配 下面 3 个函数可用于存储空间动态分配：\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdlib.h\u0026gt; void *malloc(size_t size); void *calloc(size_t nobj, size_t size); void *realloc(void *ptr, size_t newsize); 3 个函数的返回值：若成功，返回非空指针；若出错，返回 NULL malloc：分配指定字节数的存储区，此存储区的初始值不确定。 calloc：为指定数量指定长度的对象分配存储空间，该空间的每一位（bit）都初始化为 0。 realloc：增加或减少以前分配区的长度。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，以便在尾端提供增加的存储区，而新增区域内的初始值则不确定。 下面的函数可用于释放存储空间：\n1 void free(void *ptr); free 释放的空间通常被送入可用存储区池，上面 3 个函数可在需要时进行再分配。\n下面的操作可能会造成致命性错误：\n释放一个已经释放了的块。 嗲用 free 时所用的指针不是 3 个 malloc 的返回值。 如果一个进程调用 malloc 函数，但是却忘记调用 free 函数，那么该进程占用的存储空间会连续增加，这被称为 泄露。如果不调用 free 函数释放不再使用的空间，那么进程地址空间将会慢慢增长，直至不再有空闲空间。此时，由于过多的换页开销，会造成性能下降。 八、环境变量 下面的函数可以用于获取环境变量：\n1 2 3 4 5 #include \u0026lt;stdlib.h\u0026gt; char *getenv(const char *name); 返回值：指向与 name 关联的 value 的指针；如未找到，返回 NULL 下面 3 个函数可以设置环境变量：\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdlib.h\u0026gt; int putenv(char *str); 函数返回值：若成功，返回 0；若出错，返回非 0 int setenv(const char *name, const char *value, int rewrite); int unsetenv(const char *name); 两个函数返回值：若成功，返回 0；若出错，返回 -1 putenv：取形式为 name=value 的字符串，将其放入环境表中。如果 name 已存在，则先删除原来的定义。 setenv：将 name 设置为 value。如果 name 已存在： 如果 rewrite 非 0，则先删除原有定义。 如果 rewrite 为 0，则不做任何操作。 unsetenv：删除 name 的定义。 注意：putenv 和 setenv 的区别。setenv 必须分配存储空间，以便根据参数创建 name=value 的字符串。putenv 可以自由地将传递给它的参数字符串直接放到环境中。\nQ: 这些函数如何修改环境表？\nA: 环境表和环境字符串通常位于进程存储空间的顶部，即栈之上。删除一个字符串只需要在环境表中找到该指针，然后将所有后续指针都向环境表首部移动一个位置。由于在存储空间顶部，不能往上增长也不能移动它之下的栈帧，两者组合使得空间的长度不能增加。\n修改一个现有的 name。\n如果新 value 的长度小于或等于现有 value 的长度，则只要将新字符串复制到原来字符串的空间。 如果新 value 的长度大于现有 value 的长度，则必须调用 malloc 为新字符串分配空间，然后将新字符串复制到该空间中，接着使原有 name 的指针指向新分配区。 如果要增加一个新的 name，首先，必须调用 malloc 分配空间，然后将 name=value 字符串复制到该空间中。\n如果是第一次增加 name，则必须调用 malloc 为新的指针表分配空间。接着，将原来的环境表复制到新分配区，并将指向新 name=value 的字符串的指针存放在该指针表的表尾，然后又将一个空指针放在其后，最后使 environ 指向新指针表。如果原来的环境表位于栈顶之上，那么必须将表移至堆中，但是，此表的大多数指针仍指向栈顶之上的各 name=value 字符串。 如果不是第一次增加 name，则可知已经在堆中存放了环境表，则只需要调用 remalloc 分配比原来空间多存放一个指针的空间，然后将指向新 name=value 字符串的指针存放在该表表尾，后面跟着一个空指针。 九、函数 setjmp 和 longjmp 函数 setjmp 和 longjmp 可用于实现非局部 goto。非局部 goto 指的是，这不是由普通的 C 语言 goto 语句在一个函数内实现的跳转，而是在栈上跳过若干调用帧，返回到当前函数调用路径上的某一个函数中。\n1 2 3 4 5 6 7 #include \u0026lt;setjmp.h\u0026gt; int setjmp(jmp_buf env); 返回值：若直接调用，返回 0；若从 longjmp 返回，则为非 0 void longjmp(jmp_buf env, int val); 十、函数 getrlimit 和 setrlimit 每个进程都有一组资源限制，可以使用下面两个函数来查询和修改：\n1 2 3 4 5 6 7 #include \u0026lt;sys/resource.h\u0026gt; int getrlimit(int resource, struct rlimit *rlptr); int setrlimit(int resource, const struct rlimit *rlptr); 两个函数返回值：若成功，返回 0；若出错，返回非 0 rlimit 的结构如下所示：\n1 2 3 4 struct rlimit { rlim_t rlim_cur; /* soft limit: current limit */ rlim_t rlim_max; /* hard limit: maximum value for rlim_cur */ } 在更改资源限制时，必须遵循以下 3 条规则：\n任何一个进程都可以将一个软限制值修改为小于或等于其硬限制值。 任何一个进程都可以降低其硬限制值，但它必须大于或等于其软限制值。这种降低，对普通用户来说是不可逆的。 只有超级用户进程可以提高硬限制值。 资源限制只影响调用进程并由其子进程继承。为了影响所有后续进程，需要将在 shell 上进行资源限制。\n","date":"2023-02-14T15:27:39+08:00","image":"https://www.imxiejie.me/p/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/unix-book_hu4547a7503b7987387e6e836bc31e69b7_54147_120x120_fill_q75_box_smart1.jpeg","permalink":"https://www.imxiejie.me/p/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/","title":"进程环境"},{"content":"一、口令文件 UNIX 系统口令文件包含了下图所示的各个字段： 口令文件通常是 /etc/passwd，是一个 ASCII 文件，每一行都包含上图中的字段，字段之间用 : 分隔。\n例如：\n1 2 3 4 root:x:0:0:root:/root:/bin/bash squid:x:23:23::/var/spool/squid:/dev/null nobody:x:65534:65534:Nobody:/home:/bin/sh sar:x:205:105:Stephen Rago:/home/sar:/bin/bash 上述大致格式为 用户名:加密口令:用户 ID:组 ID:注释:起始目录:登录 shell 通常有一个用户名为 root 的登录项，其用户 ID 是 0（超级用户）。 加密口令字段包含了一个占位符。 口令文件项中的某些字段可能为空。 shell 字段包含了一个可执行文件名，被用作该用户的登录 shell。而如 /dev/null 不是一个可执行文件，这是一个设备，目的是为了防止以用户 squid 的名义登录系统。 为了阻止一个特定用户登录系统，除了使用 /dev/null 外，可以有多种方式： /bin/false 以不成功（非 0）状态终止。 /bin/true 以成功（0）状态终止。 nologin 打印可定制的出错信息，然后以非 0 状态终止。 使用 nobody 用户名的一个目的是，使任何人都可以登录系统，但其用户 ID 和 组 ID 不提供任何特权。 提供 finger 命令的某些系统支持注释字段中的附加信息。 下列是两个获取口令文件项的函数：\n1 2 3 4 5 6 7 #include \u0026lt;pwd.h\u0026gt; struct passwd *getpwuid(uid_t uid); struct passwd *getpwnam(const char *name); 两个函数返回值：若成功，返回指针；若出错，返回 NULL passwd 结构通常是函数内部的静态变量，只要调用任一相关函数，其内容就会被重写\n下面的函数可用于查看整个口令文件：\n1 2 3 4 5 6 7 8 9 #include \u0026lt;pwd.h\u0026gt; struct passwd *getpwent(void) 返回值：若成功，返回指针；若出错或到达文件尾端，返回 NULL void setpwent(void); void endpwent(void); getpwent 返回口令文件中的下一个记录项。 setpwent 用来将 getpwent 的读写地址指向密码文件开头。 endpwent 用来关闭这些文件。 二、阴影口令 加密口令是经单向加密算法处理过的用户口令副本，因为该算法是单向的，故不能从加密口令猜测到原来的口令。\n现在，某些系统将加密口令存放在另一个通常被称为 阴影口令 的文件中，通常是 /etc/shadow。包含下图所示字段： 普通口令文件 /etc/passwd 可被各用户自由读取，而阴影口令文件不能被一般用户读取。\n与访问口令文件相似，也有一组函数：\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;shadow.h\u0026gt; struct spwd *getspnam(const char *name); struct spwd *getspent(void); 两个函数返回值：若成功，返回指针；若出错，返回 NULL void setspent(void); void endspent(void); 三、组文件 UNIX 组文件包含了下图所示字段： 相关函数如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;grp.h\u0026gt; struct group *getgrgid(gid_t gid); struct group *getgrnam(const char *name); 两个函数返回值：若成功，返回指针；若出错，返回 NULL struct group *getgrent(void); 返回值：若成功，返回指针；若出错或到达文件尾端，返回 NULL void setgrent(void); void endgrent(void); 四、附属组 ID 一个用户不仅可以只属于一个组，也可以属于多至 16 个组。在进行检查文件访问权限时，不仅将进程的有效组 ID 和文件的组 ID 比较，还将所有附属组 ID 和文件的组 ID 进行比较。\n附属组的优点：不必经常显示更换组。\n下列函数可用于获取和设置附属组 ID：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;unistd.h\u0026gt; int getgroups(int gidsetsize, gid_t grouplist[]); 返回值：若成功，返回附属组 ID 数量；若出错，返回 -1 #include \u0026lt;grp.h\u0026gt; /* on Linux */ #include \u0026lt;unistd.h\u0026gt; /* on FreeBSD, Mac OS X, and Solaris */ int setgroups(int ngroups, const gid_t grouplist[]); #include \u0026lt;grp.h\u0026gt; /* on Linux and Solaris */ #include \u0026lt;unistd.h\u0026gt; /* on FreeBSD and Mac OS X */ int initgroups(const char *username, gid_t basegid); 两个函数返回值：若成功，返回 0；若出错，返回 -1 五、其他数据文件 一般情况下，对于每个数据文件至少有 3 个函数：\nget 函数：读取下一个记录，如果需要，还会打开文件。 set 函数：打开相应数据文件（如果未打开），然后反绕该文件。 反绕：个人理解是将读写地址指向文件开头。\nend 函数：关闭相应数据文件。 下图是有关文件的函数： 六、登录账户记录 大多数 UNIX 系统都提供下列两个数据文件：\nutmp：记录当前登录到系统的各个用户。\nwtmp：跟踪各个登录和注销事件。\n1 2 3 4 5 struct utmp { char ut_line[8]; /* tty line: \u0026#34;ttyh0\u0026#34;, \u0026#34;ttyd0\u0026#34;, \u0026#34;ttyp0\u0026#34;, ... */ char ut_name[8]; /* login name */ long ut_time; /* seconds since Epoch */ } 在登录时，login 程序填写此结构，并将其写入到 utmp 文件中，同时也将其添加到 wtmp 文件中。注销时，init 进程将 utmp 相对应的记录擦除（每个字节都填写 null 字节），并将一个新纪录填写到 wtmp 文件中。\n七、系统标识 uname 函数用来返回与主机和操作系统有关的信息：\n1 2 3 4 5 #include \u0026lt;sys/utsname.h\u0026gt; int uname(struct utsname *name); 返回值：若成功，返回非负值；若出错，返回 -1 gethostname 函数用来返回主机名：\n1 2 3 4 5 #include \u0026lt;unistd.h\u0026gt; int gethostname(char *name, int namelen); 返回值：若成功，返回 0；若出错，返回 -1 八、时间和日期例程 TODO\n","date":"2023-02-14T11:23:45+08:00","image":"https://www.imxiejie.me/p/%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E4%BF%A1%E6%81%AF/unix-book_hu4547a7503b7987387e6e836bc31e69b7_54147_120x120_fill_q75_box_smart1.jpeg","permalink":"https://www.imxiejie.me/p/%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E4%BF%A1%E6%81%AF/","title":"系统数据文件和信息"},{"content":"一、流和 FILE 对象 对于标准 I/O 库，它们的操作是围绕着 流 进行的。流是一种抽象的概念，是一种顺序读写数据的模式，它的特点是单向流动，类似于水管。当使用标准 I/O 库打开或创建一个文件，我们就已经使得一个流跟一个文件相关联。\n对于 ASCII 字符集，一个字符用一个字节表示。对于国际字符集，一个字符可以用多个字节表示。标准 I/O 文件流可用于单字节或多字节（“宽”）字符集。而 流的定向 则决定了一个流所读、写的字符是单字节还是多字节的。当一个流最初被创建时，它并没有定向，如果在一个未定向的流上使用一个单字节的 I/O 函数，那么该流的定向就会被设置为 字节定向 的，如果在一个未定向的流上使用一个多字节的 I/O 函数，那么该流的定向就会被设置为 宽定向 的。\n只有两个函数可以改变流的定向，分别是 fwide 和 freopen 函数。fwide 可以设置一个流的定向，而 freopen 会清除一个流的定向。\n1 2 3 4 5 6 7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;wchar.h\u0026gt; int fwide(FILE *fp, int mode); 返回值：若流是宽定向的，返回正值；若流是字节定向的，返回负值；若流是未定向的，返回 0 根据 mode 的不同值， fwide 执行不同。\n若 mode 是负值，则 fwide 试图将流设置为字节定向。 若 mode 是正值，则 fwide 试图将流设置为宽定向。 若 mode 为 0，则 fwide 不改变流的定向，但返回标识该流定向的值。 注意：fwide 不改变已定向流的定向，fwide 无出错返回。\n当打开一个流时，标准 I/O 函数 fopen 返回一个指向 FILE 对象的指针，该对象通常是一个结构，包含了标准 I/O 库为管理该流所需要的所有信息，包括用于实际 I/O 的文件描述符、指向用户该流缓冲区的指针、缓冲区的长度、当前在缓冲区中的字符数以及出错标志等。\n二、标准输入、标准输出和标准错误 对一个进程预定义了 3 个流，并且这 3 个流可以自动被进程使用，它们分别是：标准输入、标准输出和标准错误。这些流引用的文件同文件描述符所引用的相同。\n三、缓冲 标准 I/O 提供缓冲的目的是为了尽可能的减少 read 和 write 的调用次数。\n标准 I/O 提供以下 3 种类型的缓冲：\n全缓冲。在这种情况下，填满标准 I/O 缓冲区才进行实际的 I/O 操作。缓冲区可由标准 I/O 例程自动地 冲洗，或者可以调用函数 fflush 冲洗一个流。 冲洗：在 UNIX 环境中，冲洗有两种意思，在标准 I/O 库方面，flush 意味着将缓冲区的内容写到磁盘上。在终端驱动程序方面，flush 表示丢弃已经存储在缓冲区的数据。\n行缓冲。在这种情况下，当在输入和输出中遇到换行符时，标准 I/O 库执行 I/O 操作。当流涉及一个终端时（比如标准输入和标准输出），通常使用行缓冲。 对于行缓冲有两个限制：\n第一，因为标准 I/O 库用来收集每一行的缓冲区的长度都是固定的，所以只要填满了缓冲区，即使没有写一个换行符，也会进行 I/O 操作。\n第二（不理解），任何时候只要通过标准 I/O 库要求从一个不带缓冲的流或者从一个行缓冲的流（它从内核请求需要数据）得到输入数据，那么就会冲洗所有行缓冲输出流。\n无缓冲。在这种情况下，标准 I/O 库不对字符进行缓冲存储。标准错误流 stderr 通常是不带缓冲的。 ISO C 要求下列缓冲特征：\n当且仅当标准输入和标准输出并不指向交互式设备时，它们才是全缓冲的。 标准错误绝不会是全缓冲的。 很多系统默认使用下列缓冲类型：\n标准错误是无缓冲的。 若是指向终端设备的流，则是行缓冲的；否则是全缓冲的。 可以使用下列函数更改缓冲类型：\n1 2 3 4 5 6 7 #include \u0026lt;stdio.h\u0026gt; void setbuf(FILE *restrict fp, char *restrict buf); int setvbuf(FILE *restrict fp, char *restrict buf, int mode, size_t size); 返回值：若成功，返回 0；若出错，返回非 0 可以使用 setbuf 打开或关闭缓冲机制，为了带缓冲进行 I/O，参数 buf 必须指向一个缓冲区。通常在此之后该流就是全缓冲的，但是如果该流与一个终端设备相关，那么某些系统也可将其设置为行缓冲。为了关闭缓冲，将 buf 设置为 NULL。\n而使用 setvbuf，可以指定所需的缓冲类型，这是由 mode 参数实现的：\n_IOFBF 全缓冲 _IOLBF 行缓冲 _IONBF 不带缓冲 注意：如果在一个函数内分配一个自动变量类的标准 I/O 缓冲区，则从该函数返回之前，必须关闭该流。另外，因为某些实现将缓冲区的一部分用于存放它自己的管理操作信息，所以可以存放在缓冲区中的实际数据字节数少于 size。一般而言，应该由系统选择缓冲区长度（size 为 NULL），并自动分配缓冲区。在这种情况下关闭此流时，标准 I/O 库将自动释放缓冲区。\n下面的函数可用于在任何时候强制冲洗一个缓冲区：\n1 2 3 4 5 #include \u0026lt;stdio.h\u0026gt; int fflush(FILE *fp); 返回值：若成功，返回 0；若出错，返回 EOF 该函数会将所有未写的数据都传送至内核。如果 fp 为 NULL，那么该函数会导致所有输出流被冲洗。\n四、打开流 下面 3 个函数可用于打开一个标准 I/O 流：\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdio.h\u0026gt; FILE *fopen(const char *restrict pathname, const char *restrict type); FILE *freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp); FILE *fdopen(int fd, const char *type); 3 个函数的返回值：若成功，返回文件指针；若出错，返回 NULL freopen 函数在一个指定的流上打开一个指定的文件，如果该流已经被打开，则先关闭流。如果该流已经定向，则会清除定向。\ntype 参数指定对该 I/O 流的读、写方式： 可以调用 fclose 关闭一个打开的流：\n1 2 3 4 5 #include \u0026lt;stdio.h\u0026gt; int fclose(FILE *fp); 返回值：若成功，返回 0；若出错，返回 EOF 在文件被关闭之前，冲洗缓冲区中的输出数据，而缓冲区中的任何输入数据将被丢弃。如果标准 I/O 库已经为该流自动分配了一个缓冲区，则释放此缓冲区。\n当一个进程正常终止时，则所有带未写缓冲数据的标准 I/O 流都会被冲洗，所有打开的标准 I/O 流都被关闭。\n五、读和写流 一旦打开了流，则可以在 3 种不同类型的非格式化 I/O 种进行选择，对其进行读、写操作。\n每次一个字符的 I/O。一次读或写一个字符，如果流是带缓冲的，则标准 I/O 函数处理所有缓冲。 每次一行的 I/O。 直接 I/O。 1.输入函数 以下 3 个函数可用于一次读一个字符：\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; int getc(FILE *fp); int fgetc(FILE *fp); int getchar(void); 返回值：若成功，返回下一个字符；若已经到达文件尾端或出错，返回 EOF 因为不管到达文件尾端还是出错，3 个函数都返回一样的值，为了区分这两种情况，必须使用下列函数：\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; int ferror(FILE *fp); int feof(FILE *fp); 两个函数的返回值：若条件为真，返回非 0（真）；否则，返回 0（假） void clearerr(FILE *fp); 在大多数实现中，为每个流在 FILE 对象中维护了两个标志：\n出错标志 文件结束标志 调用 clearerr 函数可以清除这两个标志。\n从流中读取数据以后，可以调用 ungetc 将字符再压送回流中：\n1 2 3 4 5 #include \u0026lt;stdio.h\u0026gt; int ungetc(int c, FILE *fp); 返回值：若成功，返回 c；若出错，返回 EOF 压送回到流中的字符以后又可以从流中读出，但读出的顺序和压送回的顺序相反。\n回送的字符，不一定必须是上一次读到的字符。不能回送 EOF。但是当已经到达文件尾端时，仍然可以回送一个字符，下次读将返回该字符，再次读将返回 EOF。之所以可以这样做，是因为 ungetc 成功调用后会清除流的文件结束标志。\n用 ungetc 压送回字符时，并没有将它们写到底层文件或设备中，只是将它们写回标准 I/O 库的流缓冲区中。\n2.输出函数 1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; int putc(int c, FILE *fp); int fputc(int c, FILE *fp); int putchar(int c); 3 个函数的返回值：若成功，返回 c；若出错，返回 EOF 六、每次一行 I/O 下面两个函数提供每次输入一行的功能：\n1 2 3 4 5 6 7 #include \u0026lt;stdio.h\u0026gt; char *gets(char *buf); char *fgets(char *restrict buf, int n, FILE *restrict fp); 两个函数返回值：若成功，返回 buf；若已经到达文件尾端或出错，返回 NULL 这两个函数都制定了缓冲区的地址，读入的行将送入其中。gets 从标准输入读，而 fgets 从指定的流读。\n注意：gets 不推荐使用，调用者在使用 gets 时无法指定缓冲区长度，可能造成缓冲区溢出。\nputs 和 fputs 提供每次输出一行的功能：\n1 2 3 4 5 6 7 #include \u0026lt;stdio.h\u0026gt; int puts(cnst char *str); int fputs(const char *restrict str, FILE *restrict fp); 两个函数返回值：若成功，返回非负值；若出错，返回 EOF 七、标准 I/O 的效率 TODO\n八、二进制 I/O 进行二进制 I/O 时，更愿意一次读或写一个完整的结构，以下两个函数可以提供二进制 I/O 操作：\n1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp); size_t fwrite(const void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp); 两个函数的返回值：读或写的对象数 fread 和 fwrite 返回读或写的对象数。对于读，如果出错或到达文件尾端，则此数字可以少于 nobj。在这种情况下，应调用 ferror 或 feof 以判断是哪一种情况。对于写，如果返回值少于所要求的 nobj，则出错。\n二进制 I/O 只能用于读在同一系统上已写的数据，原因是：\n在一个结构中，同一成员的偏移量可能随编译程序和系统的不同而不同（由于不同的对齐要求）。 用来存储多字节整数和浮点值的二进制格式在不同的系统结构间也可能不同。 在不同系统之间交换二进制数据的实际解决办法是使用互认的规范格式。\n九、定位流 有 3 种方法可以定位流。\n1. ftell 和 fseek 函数 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; long ftell(FILE *fp); 返回值：若成功，返回当前文件位置指示；若出错，返回 -1L int fseek(FILE *fp, long offset, int whence); 返回值：若成功，返回 0；若出错，返回 -1 void rewind(FILE *fp); 对于一个二进制文件，其文件位置指示器是从文件起始位置开始度量，并以字节为度量单位。 对于文本文件，它们的文件当前位置可能不以简单的字节偏移量来度量，因为在非 UNIX 系统中，它们可能以不同的格式存放文本文件。\n2. ftello 和 fseeko 函数 1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; off_t ftello(FILE *fp); 返回值：若成功，返回当前文件位置；若出错，返回 (off_t) - 1 int fseeko(FILE *fp, off_t offset, int whence); 返回值：若成功，返回 0；若出错，返回 -1 3. fgetpos 和 fsetpos 函数 1 2 3 4 5 6 7 #include \u0026lt;stdio.h\u0026gt; int fgetpos(FILE *restrict fp, fpos_t *restrict pos); int fsetpos(FILE *fp, const fpos_t *pos); 返回值：若成功，返回 0；若出错，返回非 0 十、格式化 I/O 1. 格式化输出 格式化输出由下列 5 个函数处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; int printf(const char *restrict format, ...); int fprintf(FILE *restrict fp, const char *restrict format, ...); int dprintf(int fd, const char *restrict format, ...); 3 个函数的返回值：若成功，返回输出字节数；若输出出错，返回负值 int sprintf(char *restrict buf, const char *restrict format, ...); 返回值：若成功，返回存入数组的字符数；若编码出错，返回负值 int snprintf(char *restrict buf, size_t n, const char *restrict format, ...); 返回值：若缓冲区足够大，返回将要存入数组的字符数；若编码出错，返回负值 sprintf 可能会造成由 buf 指向的缓冲区的溢出。\n格式说明\n%[flags][fldwidth][precision][lenmodifier]convtype\nflags fldwidth 说明最小字段宽度。 precision 说明整形转换后最少输出数字位数、浮点数转换后小数点后的最小位数、字符串转换后最大字节数。精度是一个点（.），其后跟随一个可选的非负十进制数或一个星号（*）。 lenmodifier 说明参数长度。 convtype 不是可选的，它控制如何解释参数。 下面 5 个 printf 函数类似于上面 5 种，但是可变参数（...）替换成了 arg。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdarg.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int vprintf(const char *restrict format, va_list arg); int vfprintf(FILE *restrict fp, const char *restrict format, va_list arg); int vdprintf(int fd, const char *restrict format, va_list arg); 3 个函数返回值：若成功，返回输出字符数；若出错，返回负值 int vsprintf(char *restrict buf, const char *restrict format, va_list arg); 函数返回值：若成功，返回存入数组的字符数；若编码出错，返回负值 int vsnprintf(char *restrict buf, size_t n, const char *restrict format, va_list arg); 返回值：若缓冲区足够大，返回存入数组的字符数；若编码出错，返回负值 2. 格式化输入 下列 3 个函数可以处理格式化输入：\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; int scanf(const char *restrict format, ...); int fscanf(FILE *restrict fp, const char *restrict format, ...); int sscanf(const char *restrict buf, const char *restrict format, ...); 返回值：赋值的输入项数；若输入出错或在任一转换前已到达文件尾端，返回 EOF 格式说明\n%[*][fldwidth][m][lenmodifier]convtype\n* 号用于抑制转换。 fldwidth 说明最大宽度，即最大字符数。 lenmodifier 说明要用转换结果赋值的参数大小。 convtype 下面函数同样使用 arg 替换 ...：\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdarg.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int vscanf(const char *restrict format, va_list arg); int vfscanf(FILE *restrict fp, const char *restrict format, va_list arg); int vsscanf(const char *restrict buf, const char *restrict format, va_list arg); 3 个返回值：指定的输入项目数；若输入出错或在任一转换前文件结束，返回 EOF 十一、实现细节 每个标准 I/O 流都有一个与其相关联的文件描述符，可以用 fileno 获取一个流的文件描述符。\n1 2 3 4 5 #include \u0026lt;stdio.h\u0026gt; int fileno(FILE *fp); 返回值：与该流相关联的文件描述符 // TODO\n十二、临时文件 下面两个函数可用于创建临时文件：\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; char *tmpnam(char *ptr); 返回值：指向唯一路径名的指针 FILE *tmpfile(void); 返回值：若成功，返回文件指针；若出错，返回 NULL 注意：UNIX 对二进制文件不进行特殊区分。\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdlib.h\u0026gt; char *mkdtemp(char *template); 返回值：若成功，返回指向目录名的指针；若出错，返回 NULL int mkstemp(char *template); 返回值：若成功，返回文件描述符；若出错，返回 -1 十三、内存流 TODO\n","date":"2023-02-13T15:29:52+08:00","image":"https://www.imxiejie.me/p/%E6%A0%87%E5%87%86-i/o-%E5%BA%93/unix-book_hu4547a7503b7987387e6e836bc31e69b7_54147_120x120_fill_q75_box_smart1.jpeg","permalink":"https://www.imxiejie.me/p/%E6%A0%87%E5%87%86-i/o-%E5%BA%93/","title":"标准 I/O 库"},{"content":"一、MySQL 架构 二、隔离级别 READ UNCOMMITTED （未提交读）\n在 READ UNCOMMITTED 隔离级别下，事务中的修改，即使么有提交，对其他事务都是可见的。事务可以读取未提交的数据，这被称为 脏读。该隔离级别在实际中很少使用。\nREAD COMMITTED（提交读）\n在 READ COMMITTED 下，一个事务开始时，只能“看见”已经提交的修改。一个事务在提交之前，所做的任何修改对其他事务都是不可见的。但这个级别也被称为 不可重复读，因为两次执行相同的查询，得到的结果可能是不一样的。\nREPEATABLE READ（可重复读）\n在 REPEATABLE READ 下，事务多次读取同样的记录，结果是一致的。但在理论上，可重复读无法解决另一个 幻读 的问题。所谓幻读，指的是当某个事务在读取某个范围内的数据时，另外一个事务在该范围内插入了新的数据，当之前的事务再次读取该范围时，会产生 幻行。\nInnoDB 通过多版本并发控制（MVCC）解决幻读问题。\nSERIALIZABLE（串行化）\nSERIALIZABLE 是最高的隔离级别，在该级别下，所有事务都被强制串行执行，避免了幻读问题。简单来说，SERIALIZABLE 会讲读取的每一行数据上都加上锁，所以可能导致大量的超时和锁争用问题。实际中很少使用该隔离级别。 三、MVCC （多版本并发控制） MVCC 是通过保存数据在某个时间的快照来实现的，典型的有 乐观并发控制 和 悲观并发控制 具体实现根据存储引擎的不同而不同，在这里主要关注 InnoDB。\n在 InnoDB 中，MVCC 是通过在行最后添加两个隐藏列来实现的，一个是创建时间，一个是过期时间（或删除时间），当然，这存储的并不是时间值，而是事务版本号，每个事务在开始时都会被分配一个版本号（版本号是递增的）。下面看一下在 REPEATABLE READ 隔离级别下，MVCC 具体是如何操作的。\nSELECT\nInnoDB 会根据以下两个条件来检查每行记录：\nInnoDB 只会查找版本号小于等于当前版本号的数据行，这样可以保证事务读取的行，要么是事务开始前已经存在的，要么是当前事务操作的。 行的删除版本号要么未定义，要么大于当前事务版本号。这样可以保证事务读取到的行在事务开始前没有被删除。 INSERT\nInnoDB 为新插入的每一行保存当前版本号作为行版本号。\nDELETE\nInnoDB 为删除的每一行保存当前版本号作为删除标识。\nUPDATE\nInnoDB 为插入一行新纪录，保存当前版本号作为行版本号，同时保存当前版本号作为原来的行的删除标识。\n保存这两个版本号，使得大多数的操作都可以不用加锁。在提升性能的同时，也有不足之处。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作以及一些额外的维护工作。\nMVCC 只在 REPEATABLE READ 和 READ COMMITTED 两个隔离级别下工作。其他两个隔离级别都和 MVCC 不兼容，因为 READ UNCOMMITTED 总是读取最新的行，而 SERIALIZABLE 会对所有读取到的行都加锁。\n","date":"2023-02-11T21:02:47+08:00","permalink":"https://www.imxiejie.me/p/mysql-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"MySQL 学习笔记"},{"content":"一、函数 stat、fstat、fstatat 和 lstat 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;sys/stat.h\u0026gt; int stat(const char *restrict pathname, struct stat *restrict buf); int fstat(int fd, struct stat *buf); int lstat(const char *restrict pathname, struct stat *restrict buf); int fstatat(int fd, const char *restrict pathname, struct stat *restrict buf, int flag); 所有 4 个函数的返回值：若成功，返回 0；若出错，返回 -1 stat：一旦给出 pathname ，将返回与该命名文件有关的信息结构。\nfstat：获得在 fd 上打开文件的有关信息。\nlstat：类似于 stat，但当命名文件是一个符号链接时，lstat 返回该符号链接的有关信息，而不是由该符号链接引用的文件的信息。\nfstatat：为一个相当于当前打开目录（由 fd 参数指向）的路径名返回文件统计信息，flag 参数控制着是否跟随者一个符号链接。当 AT_SYMLINK_NOFOLLOW 标志被设置时，fstatat 不会跟随符号链接。\nstat 大致结构如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct stat { mode_t st_mode; /* file type \u0026amp; mode (permissions) */ ino_t st_ino; /* i-node number (serial number) */ dev_t st_dev; /* device number (file system) */ dev_t st_rdev; /* device number for special files */ nlink_t st_nlink; /* number of links */ uid_t st_uid; /* user ID of owner */ gid_t st_gid; /* group ID of owner */ off_t st_size; /* size in bytes, for regular files */ struct timespec st_atime; /* time of last access */ struct timespec st_mtime; /* time of last modificaiton */ struct timespec st_ctime; /* time of last file status change */ blksize_t st_blksize; /* best I/O block size */ blkcnt_t st_blocks; /* number of disk blocks allocated */ } 二、文件类型 文件类型包含以下几种：\n普通文件（regular file）。这种文件包含了某种形式的数据，至于这种数据是文本还是二进制数据，对于 UNIX 内核毫无区别。对普通文件内容的解释由处理该文件的应用程序进行。 目录文件（directory file）。这种文件包含了其他文件的名字以及指向这些文件有关信息的指针。对一个目录文件具有读权限的任一进程都可以读该目录的内容，但只有内核才可以直接写目录文件。 块特殊文件（block special file）。这种类型的文件提供对设备（如磁盘）带缓冲的访问，每次访问以固定长度进行。 字符特殊文件（character special file）。这种类型的文件提供对设备不带缓冲的访问，每次访问长度可变。系统中的设备要么是块特殊文件，要么是字符特殊文件。 FIFO。这种类型的文件用于进程间通信，有时也称为 命名管道（named pipe）。 套接字（socket）。这种类型的文件用于进程间的网络通信，也可用于一台宿主机上进程间的非网络通信。 符号链接（symbolic link）。这种类型的文件指向另一个文件。 三、设置用户 ID 和 设置组 ID 实际用户 ID 和 实际组 ID 标识我们究竟是谁。这两个字段在登录时取自口令文件中的登录项。 有效用户 ID、有效组 ID 和 附属组 ID 决定了我们的文件访问权限。 保存的设置用户 ID 和 保存的设置组 ID 在执行一个程序时包含了有效用户 ID 和有效组 ID 的副本。 通常，执行一个程序文件时，进程的有效用户 ID 就是实际用户 ID，有效组 ID 就是实际组 ID。但是，可以在 文件模式字（st_mode） 中设置一个特殊标志。其含义是：“当执行此文件时，将进程的有效用户 ID 设置为文件所有者的用户 ID（st_uid）”，与此类似，在文件模式字中可以设置另一位，它将执行此文件的进程的有效组 ID 设置为该文件的组所有者 ID（st_gid）。在文件模式字中，这两位被称为 设置用户 ID（set-user-ID）位 和 设置组 ID（set-group-ID）位。\n例如：如果文件所有者是超级用户，而且设置了该文件的设置用户 ID 位，那么当该程序文件由一个进程执行时，该进程具有超级用户权限。不管执行此文件的进程的实际用户 ID 是什么，都会是这样。\n四、文件访问权限 st_mode 也包含了对文件的访问权限位，下图是 9 个权限访问位：\n通常使用 u 表示用户（所有者），用 g 表示组，用 o 表示其他。\n各种访问权限使用如下：\n当我们用名字打开任一类型的文件时，对该名字的包含的每一个目录，包括它可能隐含的当前工作目录都应该具有执行权限。 故对于目录的执行权限位为什么常被称为搜索位。\n对于一个文件的读权限决定了我们是否能够打开现有文件进行读操作。 对于一个文件的写权限决定了我们时候能够打开现有文件进行写操作。 为了在 open 函数中对一个文件指定 O_TRUNC 标志，必须对该文件具有写权限。 为了在一个目录中创建一个文件，必须对该目录具有写权限和执行权限。 为了删除一个现有文件，必须对包含该文件的目录具有写权限和执行权限。对该文件本身不需要有读、写权限。 如果用 7 个 exec 函数中的任何一个执行文件，必须对该文件具有执行权限。该文件还必须是普通文件。 进程每次打开、创建或删除一个文件时，内核就进行文件访问权限测试。而这种测试可能涉及文件的所有者（st_uid 和 st_gid）、进程的有效 ID（有效用户 ID 和 有效组 ID）以及进程的附属组 ID。两个所有者 ID 是文件的性质，而两个有效 ID 和 附属组 ID 是进程的性质。\n内核进行权限测试的流程如下：\n若进程的有效用户 ID 是 0（超级用户），则允许访问。 若进程的有效用户 ID 等于文件的所有者 ID，如果适当的访问权限被设置，则允许访问；否则拒绝访问。 若进程的有效组 ID 或进程的附属组 ID 之一等于文件的组 ID，如果适当的访问权限被设置，则允许访问；否则拒绝访问。 若其他用户适当的访问权限被设置，则允许访问；否则拒绝访问。 五、新文件和目录的所有权 新文件的用户 ID 设置为进程的有效用户 ID。\n而对于新文件的组 ID：\n新文件的组 ID 可以是进程的有效组 ID。 新文件的组 ID 可以是它所在目录的组 ID。 对于部分系统，默认情况下，新文件的组 ID 取决于它所在的目录的设置组 ID 位是否被设置。如果该位被设置，则新文件的组 ID 设置为目录的组 ID；否则设置为进程的有效组 ID。（目录的组 ID 优先于进程的组 ID）\n六、函数 access 和 faccessat 当用 open 函数打开一个文件时，内核以进程的有效用户 ID 和有效组 ID 为基础执行其访问权限测试。如果想按实际用户 ID 和实际组 ID 进行访问权限测试，可以使用 access 和 faccessat 函数：\n1 2 3 4 5 6 7 #include \u0026lt;unistd.h\u0026gt; int access(const char *pathname, int mode); int faccessat(int fd, const char *pathname, int mode, int flag); 两个函数的返回值：若成功，返回 0；若出错，返回 -1 flag 参数可以用于改变 faccessat 的行为，如果 flag 设置为 AT_EACCESS，访问检查用的是调用进程的有效用户 ID 和有效组 ID，而不是实际用户 ID 和实际组 ID。\n七、函数 umask umask 函数为进程设置文件模式创建屏蔽字，并返回之前的值。\n1 2 3 4 5 #include \u0026lt;sys/stat.h\u0026gt; mode_t umask(mode_t cmask); 返回值：之前的文件模式创建屏蔽字 在文件模式创建屏蔽字中为 1 的位，在文件 mode 中的相应位一定会被关闭。更改进程的文件模式创建屏蔽字并不影响其父进程（通常是 shell）的屏蔽字。\n八、函数 chmod、fchmod 和 fchmodat 1 2 3 4 5 6 7 8 9 #include \u0026lt;sys/stat.h\u0026gt; int chmod(const char *pathname, mode_t mode); int fchmod(int fd, mode_t mode); int fchmodat(int fd, const char *pathname, mode_t mode, int flag); 3 个函数返回值：若成功，返回 0；若出错，返回 -1 为了改变一个文件的权限位，进程的有效用户 ID 必须等于文件的所有者 ID，或者该进程必须拥有超级用户权限。\n参数 mode 是下图所示常量的按位或： 九、黏着位 S_ISVTX 在 UNIX 尚未使用请求分页技术的早期版本中，S_ISVTX 位被称为 黏着位。如果一个可执行程序的这一位被设置了，那么当该程序第一次被执行，在其终止时，程序正文部分的一个副本仍被保存在交换区（程序的正文部分是机器指令）。这使得下次执行该程序时能够较快地将其载入内存。\n原因：早期的 UNIX 文件系统中，文件的各数据块很可能是随机存放的，相比较而言，交换区是被作为一个连续文件来处理的\n现今的系统扩展了黏着位的使用范围，某些系统允许针对目录设置黏着位，如果对一个目录设置了黏着位，只有对该目录具有写权限的用户并且满足下列条件之一，才能删除或重命名改目录下的文件：\n拥有此文件。 拥有此目录。 是超级用户。 十、函数 chown、fchown、fchownat 和 lchown 下面的函数可用于改变文件的用户 ID 和组 ID，如果两个参数 owner 和 group 中的任意一个是 -1，则对应的 ID 不变。\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;unistd.h\u0026gt; int chown(const char *pathname, uid_t owner, gid_t group); int fchown(int fd, uid_t owner, gid_t group); int fchownat(int fd, const char *pathname, uid_t owner, gid_t group, int flag); int lchown(const char *pathname, uid_t owner, gid_t group); 4 个函数的返回值：若成功，返回 0；若出错，返回 -1 在符号链接情况下，lchown 和 fchownat（设置了 AT_SYMLINK_NOFOLLOW 标志）更改符号链接本身的所有者，而不是该符号链接所指向的文件的所有者。除了符号链接外，这 4 个函数的操作相似。\n不同系统对于修改文件所有者的设定不同，基于 BSD 的系统一直规定只有超级用户才能更改一个文件的所有者。这样做的原因是防止用户改变其文件的所有者从而摆脱磁盘空间限额对他们的限制。System V 则允许任一用户更改他们所拥有文件的所有者。\n按照 _POSIX_CHOWN_RESTRICTED 的值，如果该值对指定的文件生效，则：\n只有超级用户进程才能更改该文件的用户 ID。 如果进程拥有此文件（其有效用户 ID 等于该文件的用户 ID），参数 owner 等于 -1 或文件的所有者 ID，并且参数 group 等于进程的有效组 ID 或进程的附属组 ID 之一，那么一个非超级用户进程可以修改此文件的组 ID。 这意味着，当 _POSIX_CHOWN_RESTRICTED 有效时，不能更改其他用户文件的用户 ID。你可以更改你所拥有文件的组 ID，但只能改到你属于的组。\n如果这些函数非超级用户进程调用，则在成功返回时，该文件的设置用户 ID 位和设置组 ID 位都被清除。\n十一、文件长度 stat 结构成员 st_size 表示以字节为单位的文件的长度，此字段只对普通文件、目录文件和符号链接有意义。 对于普通文件，其文件长度可以为 0，在开始读这种文件时，将得到 EOF 指示。对于目录，文件长度通常是一个数（如 16 或 512）的整倍数。对于符号链接，文件长度是在文件名中的实际字节数。\n注意：因为符号链接文件长度总是由 st_size 表示，所以它并不包含通常 C 语言用作名字结尾的 null 字符。\n文件空洞 文件空洞 是由所设置的偏移量超过文件尾端，并写入了某些数据后造成的。文件空洞并不占据磁盘空间。\n如果使用实用程序（如 cat(1)）复制文件，那么文件空洞将会被填满，其中所有的实际字节数据都被填写为 0。\n十二、文件截断 1 2 3 4 5 6 7 #include \u0026lt;unistd.h\u0026gt; int truncate(const char *pathname, off_t length); int ftruncate(int fd, off_t length); 两个函数的返回值：若成功，返回 0；若出错，返回 -1 这两个函数将一个现有文件截断为 length。如果该文件长度大于 length，则超过 length 的部分的数据就不能再访问。如果以前的长度小于 length，文件长度将在呢个价，在以前的文件尾端和新的文件尾端之间的数据将读作 0。（也就是可能在文件中创建了一个空洞）。\n十三、文件系统 UFS 是以 Berkeley 快速文件系统为基础的，如图所示：\n一个磁盘可以分为一个或多个分区，每个分区可以包含一个文件系统。i 节点是固定长度的记录项，它包含有关文件的大部分信息。 如果更仔细地观察一个柱面组的 i 节点和数据块部分，则可看到下图所示：\n图中有两个目录项指向同一个 i 节点，每个 i 节点中都有一个链接计数，其值是指向该 i 节点的目录项数。只有当链接计数减少至 0 时，才可删除该文件（即可以释放该文件所占用的数据块）。这种链接类型被称为硬链接。 另外一种链接被称为符号链接（或软链接）。符号链接文件的实际内容包含了该符号链接所指向的文件的名字。 i 节点包含了文件有关的所有信息：文件类型、文件访问权限位、文件长度和指向文件数据块的指针等。目录项包含了文件名和 i 节点编号。 因为目录项的 i 节点编号同一文件系统中的相应 i 节点，故一个目录项不能指向另一个文件系统给的 i 节点。 在不更换文件系统的情况下为一个文件重命名时，该文件的实际内容并未移动，只需构造一个指向现有 i 节点的新目录项，并删除老的目录项。链接计数不会改变。 任何一个叶目录（不包含其他任何目录的目录）的链接计数总是 2，数值 2 来自于命名该目录的目录项以及在该目录中的 . 项。其他目录的链接计数总是大于或等于 3，相比较于叶目录，至少多了一个..项。 十四、函数 link、linkat、unlink、unlinkat 和 remove 任何一个文件可以有多个目录项指向其 i 节点，创建一个指向现有文件的链接的方法是使用 link 函数或 linkat 函数。\n1 2 3 4 5 6 7 8 #include \u0026lt;unistd.h\u0026gt; int link(const char *pathname, const char *newpath); int linkat(int efd, const char *existingpath, int nfd, const char *newpath, int flag); 两个函数的返回值：若成功，返回 0；若出错，返回 -1 这两个函数创建一个新目录项 newpath，它引用现有文件 existingpath。如果 newpath 已经存在，则返回出错。只创建 newpath 中的最后一个分量，路径中的其他部分应当已经存在。\n大多数实现要求现有的和新建的两个路径名在同一文件系统中。如果实现支持创建指向一个目录的硬链接，那么也仅限于超级用户才可以这样做，因为这样做可能在文件系统中形成循环。\n为了删除一个现有的目录项，可以调用 unlink 函数。\n1 2 3 4 5 6 7 #include \u0026lt;unistd.h\u0026gt; int unlink(const char *pathname); int unlinkat(int fd, const char *pathname, int flag); 两个函数的返回值：若成功，返回 0；若出错，返回 -1 这两个函数将删除目录项，并将由 pathname 所引用的文件链接计数减 1.如果对该文件还有其他链接，仍然可以通过其他链接访问该文件的数据。如果出错，则不对该文件做任何修改。\n只有当链接计数达到 0 时，该文件的内容才可以被删除。另一个条件也会阻止删除文件的内容\u0026ndash;只要有进程打开了该文件，其内容也不能被删除。关闭一个文件时，内核首先会检查打开该文件的进程数，如果进程数为 0，再去检查其链接数，如果链接数也是 0，则会删除该文件的内容。\n也可以用 remove 函数解除对一个文件或目录的链接，如果是文件，remove 的功能与 unlink 相同，如果是目录，remove 的功能与 rmdir 相同。\n1 2 3 4 5 #include \u0026lt;stdio.h\u0026gt; int remove(const char *pathname); 返回值：若成功，返回 0；若出错，返回 -1 十五、函数 rename 和 renameat 文件或目录可以使用 rename 或 renameat 函数进行重命名。\n1 2 3 4 5 6 7 #include \u0026lt;stdio.h\u0026gt; int rename(const char *oldname, const char *newname); int renameat(int oldfd, const char *pathname, int newfd, const char *newname); 两个函数的返回值：若成功，返回 0；若出错，返回 -1 如果 oldname 指向的是一个文件而不是目录，那么为该文件或符号链接重命名。 如果 oldname 指向的是一个目录，那么为该目录重命名。 如果 oldname 或 newname 引用符号链接，则处理的是符号链接本身，而不是它所引用的文件。 不能对 . 和 .. 重命名。 作为一个特例，如果 oldname 和 newname 引用同一文件，则函数不做任何更改而成功返回。 十六、符号链接 符号链接是对一个文件的间接指针，而硬链接直接指向文件的 i 节点。引入符号链接的原因是为了避开硬链接的一些限制：\n硬链接通常要求链接和文件位于同一文件系统中。 只有超级用户才能创建指向目录的硬链接。（在底层文件系统支持的情况下，同时为了避免循环） 对符号链接以及它指向何种对象并无任何的文件系统限制，任何用户都可以创建指向目录的符号链接。符号链接一般用于将一个文件或整个目录结构移到系统中的另一个位置。\n下图展示了部分函数对于符号链接的跟随情况： 十七、创建和读取符号链接 可以用 symlink 或 symlinkat 函数创建一个符号链接。\n1 2 3 4 5 6 7 #include \u0026lt;unistd.h\u0026gt; int symlink(const char *actualpath, const char *sympath); int symlinkat(const char *actualpath, int fd, const char *sympath); 两个函数的返回值：若成功，返回 0；若出错，返回 -1 函数创建了一个指向 actualpath 的新目录项 sympath。在创建此符号链接时，并不要求 actualpath 已经存在。并且，actualpath 和 sympath 并不需要位于同一文件系统中。\n因为 open 函数跟随符号链接，所以需要有一种方法打开该链接本身，并读该链接中的名字。readlink 和 readlinkat 函数提供了这种功能。\n1 2 3 4 5 6 7 8 9 #include \u0026lt;unistd.h\u0026gt; ssize_t readlink(const char *restrict pathname, char *restrict buf, size_t bufsize); ssize_t readlinkat(int fd, const char *restrict pathname, char *restrict buf, size_t bufsize); 两个函数的返回值：若成功，返回读取的字节数；若出错，返回 -1 十八、文件的时间 每个文件属性所保存的实际精度依赖于文件系统的视线。对于把时间戳记录在秒级的文件系统来说，纳秒这个字段就会被填充为 0。对于时间戳的记录精度高于秒级的文件系统来说，不足秒的值被转换为纳秒并记录在纳秒这个字段中。\n每个文件维护 3 个时间字段： 注意：修改时间（st_mtime）和状态更改时间（st_ctime）之间的区别。修改时间是文件内容最后一次被修改的时间。状态更改时间是该文件的 i 节点最后一次被修改的时间。\n注意：系统并不维护对一个 i 节点的最后一次访问时间。\n十九、函数 futimens、utimensat 和 utimes 一个文件的访问和修改时间可以用以下几个函数更改，futimens 和 utimensat 函数可以指定纳秒级精度的时间戳。用到的数据结构是与 stat 函数族相同的 timespec 结构。\n1 2 3 4 5 6 7 #include \u0026lt;sys/stat.h\u0026gt; int futimens(int fd, const struct timespec times[2]); int utimensat(int fd, const char *path, const struct timespec times[2], int flag); 两个函数的返回值：若成功，返回 0；若出错，返回 -1 times 数组参数：第一个元素包含访问时间，第二个元素包含修改时间。\n时间戳可以按下列 4 种方式之一进行制定。\n如果 times 参数是一个空指针，则访问时间和修改时间两者都设置为当前时间。 如果 times 参数指向两个 timespec 结构的数组，任一数组元素的 tv_nsec 字段的值为 UTIME_NOW，相应的时间戳就设置为当前时间，忽略相应的 tv_sec 字段。 如果 times 参数指向两个 timespec 结构的数组，任一数组元素的 tv_nsec 字段的值为 UTIME_OMIT，相应的时间戳保持不变，忽略相应的 tv_sec 字段。 如果 times 参数指向两个 timespec 结构的数组，且 tv_nsec 字段的值既不是 UTIME_NOW 也不是 UTIME_OMIT，在这种情况下，相应的时间戳设置为相应的 tv_sec 和 tv_nsec 字段的值。 执行这些函数所要求的优先权取决于 times 参数的值。\n如果 times 是一个空指针，或者任一 tv_nsec 字段设为 UTIME_NOW，则进程的有效用户 ID 必须等于该文件的所有者 ID；进程对该文件必须具有写权限，或者进程是一个超级用户进程。 如果 times 是一个非空指针，并且任一 tv_nsec 字段的值既不是 UTIME_NOW 也不是 UTIME_OMIT，则进程的有效用户 ID 必须等于该文件的所有者 ID，或者进程必须是一个超级用户进程。对文件只具有写权限是不够的。 如果 times 是非空指针，并且两个 tv_nsec 字段的值都为 UTIME_OMIT，就不执行任何的权限检查。 1 2 3 4 5 #include \u0026lt;sys/time.h\u0026gt; int utimes(const char *pathname, const struct timeval times[2]); 返回值：若成功，返回 0；若出错，返回 -1 注意：我们不能对状态更改时间 st_ctime （i 节点最近被修改的时间）指定一个只，因为调用 utimes 函数时，该字段会被自动更新。\n二十、函数 mkdir、mkdirat 和 rmdir mkdir 和 mkdirat 可以用来创建目录，rmdir 可以用来删除目录。\n1 2 3 4 5 6 7 #include \u0026lt;sys/stat.h\u0026gt; int mkdir(const char *pathname, mode_t mode); int mkdirat(int fd, const char *pathname, mode_t mode); 返回值：若成功，返回 0；若出错，返回 -1 这两个函数创建一个新的空目录。其中 . 和 .. 目录项是自动创建的。所指定的文件访问权限 mode 由进程的文件模式创建屏蔽字修改。\n常见的错误是指定与文件相同的 mode（只指定读、写权限）。但是，对于目录通常至少要设置一个执行权限位，以允许访问该目录中的文件名。\n用 rmdir 函数可以删除一个空目录。空目录是只包含 . 和 .. 这两项的目录。\n1 2 3 4 5 #include \u0026lt;unistd.h\u0026gt; int rmdir(const char *pathname); 返回值：若成功，返回 0；若出错，返回 -1 如果调用此函数使目录的链接计数为 0，并且没有其他进程打开此目录，则释放由此目录占用的空间。如果在链接计数达到 0 时，有一个或多个进程打开此目录，则在此目录返回前删除最后一个链接及 . 和 .. 项。另外，在此目录中不能再创建新文件。但是在最后一个进程关闭它之前都不释放此目录。即使其他进程打开此目录，也不能执行其他操作，这样做是因为要保证 rmdir 成功执行，则必须保证目录是空的。\n二十一、读目录 对某个目录具有访问权限的任一用户都可以读该目录，但是，为了防止文件系统产生混乱，只有内核才能写目录。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;dirent.h\u0026gt; DIR *opendir(const char *pathname); DIR *fdopendir(int fd); 两个函数返回值：若成功，返回指针；若出错，返回 NULL struct dirent *readdir(DIR *dp); 返回值：若成功。返回指针；若在目录尾或出错，返回 NULL void rewinddir(DIR *dp); int closedir(DIR *dp); 返回值：若成功，返回 0；若出错，返回 -1 long telldir(DIR *dp); 返回值：与 dp 关联的目录中的当前位置 void seekdir(DIR *dp, long loc); 二十二、函数 chdir、fchdir 和 getcwd 每个进程都有一个当前工作目录，此目录是搜索所有相对路径名的起点。当用户登录到 UNIX 系统时，其当前工作目录通常是口令文件中该用户登录项的第 6 个字段\u0026ndash;用户的起始目录。\n当前工作目录是进程的一个属性，并不影响其他进程，为了改变 shell 进程自己的工作目录，shell 应当直接调用 chdir 函数，为此，cd 命令内嵌在 shell 中。起始目录是登录名的一个属性。\n通过 chdir 或 fchdir 函数可以修改当前工作目录。\n1 2 3 4 5 6 7 #include \u0026lt;unistd.h\u0026gt; int chdir(const char *pathname); int fchdir(int fd); 两个函数的返回值：若成功，返回 0；若出错，返回 -1 通过 getcwd 可以获取当前工作目录的完整路径名。\n1 2 3 4 5 #include \u0026lt;unistd.h\u0026gt; char *getcwd(char *buf, size_t size); 返回值：若成功，返回 buf；若出错，返回 NULL buf：缓冲区地址，必须有足够的长度以容纳绝对路径名再加上一个终止 null 字节。\nsize：缓冲区长度。\n二十三、设备特殊文件 TODO\n二十四、文件权限位小结 ","date":"2023-02-10T16:42:32+08:00","image":"https://www.imxiejie.me/p/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/unix-book_hu4547a7503b7987387e6e836bc31e69b7_54147_120x120_fill_q75_box_smart1.jpeg","permalink":"https://www.imxiejie.me/p/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/","title":"文件和目录"},{"content":"一、文件描述符 文件描述符（file descriptor） 是一个非负整数，对于内核而言，所有打开的文件都通过文件描述符引用。当创建一个新文件或打开一个现有文件时，内核向进程返回一个文件描述符。\n按照惯例，UNIX 系统 shell 把文件描述符 0 跟进程的标准输入关联，1 跟标准输出关联，2 跟标准错误关联。\n文件描述符的变化范围因系统而异，为 0 ~ OPEN_MAX - 1。早期的 UNIX 系统实现采用的上限值是 19，现在的系统大多数将上限值提升至 63。对于其他一些系统，文件描述符的变化范围是无限的，它只受到系统配置的存储器总量、整形的字长以及系统管理员所配置的软限制和硬限制的约束。\n二、函数 open 和 openat 1 2 3 4 5 6 7 #include \u0026lt;fcntl.h\u0026gt; int open(const char *path, int oflag, ... /* mode_t mode */); int openat(int fd, const char *path, int oflag, ... /* mode_t mode */); 两函数的返回值：若成功，返回文件描述符；若出错，返回 -1 最后一个参数写为 \u0026hellip;，ISO C 用这种方法表明余下的参数的数量及其类型是可变的。\n对于 open 函数而言，仅当创建新文件时才使用最后这个参数。\n由 open 和 openat 函数返回的文件描述符一定是最小的未用的描述符值。\nopen 和 openat 函数的区别在于：\npath 参数指定的是绝对路径名，这种情况下，fd 参数将被忽略，openat 函数就相当于 open 函数。 path 参数指定的是相对路径名，fd 参数指出了相对路径名在文件系统中的开始地址。fd 参数是通过打开相对路径名所在的目录来获取的。 path 参数指定了相对路径名，fd 参数具有特殊值 AT_FDCWD。这种情况下，路径名在当前工作目录中获取，openat 函数在操作上与 open 函数类似。 AT_FDCWD ，该宏的值是 -100，它主要用来指示 openat 应使用当前工作目录。\nopenat 函数是 POSIX.1 最新版本中新增的一类函数之一，希望解决两个问题：\n让线程可以使用相对路径名打开文件，而不再只能打开当前工作目录。 可以避免 time-of-check-to-time-of-use（TOCTTOU） 错误。 TOCTTOU 错误的基本思想是：如果有两个基于文件的系统调用，其中第二个调用依赖于第一个调用的结果，那么程序就是脆弱的。因为两个调用不是原子操作，在两个调用之间，文件可能改变了，这也就造成了第一个调用的结果不再有效，使得程序的最终结果是错误的。\n三、函数 creat 1 2 3 4 5 #include \u0026lt;fcntl.h\u0026gt; int creat(const char *path, mode_t mode); 返回值：若成功，返回为只写打开的文件描述符；若出错，返回 -1 creat 函数一个不足之处在于它以 只写 方式打开所创建的文件。\n四、函数 close 1 2 3 4 #include \u0026lt;unistd.h\u0026gt; int close(int fd); 返回值：若成功，返回 0；若出错，返回 -1 关闭一个文件时，会释放该进程加在该文件上的所有记录锁。\n当一个进程终止时，内核会自动关闭它所有打开的文件。\n五、函数 lseek 每个打开文件都有一个与其相关联的 “当前文件偏移量”（current file offset）。它通常是一个非负整数，用以度量从文件开始处计算的字节数。通常，读、写操作都从当前文件偏移处开始，并使偏移量增加所读写的字节数。按系统默认的情况，当打开一个新文件时，除非指定 O_APPEND 选项，否则该偏移量被设置为 0。\n1 2 3 4 5 #include \u0026lt;unistd.h\u0026gt; off_t lseek(int fd, off_t offset, int whence); 返回值：若成功，返回新的文件偏移量；若出错，返回 -1 对参数 offset 的解释与参数 whence 的值有关。\n若 whence 是 SEEKSET，则将该文件的偏移量设置为距文件开始处 _offset 个字节。 若 whence 是 SEEKCUR，则将该文件的偏移量设置为当前值加上 _offset 个字节，offset 可正可负。 若 whence 是 SEEKEND，则将该文件的偏移量设置为文件长度加上 _offset，offset 可正可负。 通常，文件的当前偏移量应该是一个非负整数，但是，某些设备也可能允许负的偏移量。但对于普通文件，其偏移量必须是一个非负值。因为偏移量可能是负值，所以在比较 lseek 的返回值时，不应检测它是否小于 0，而应该检测它是否等于 -1。\nlseek 仅将当前偏移量记录在内核中，它并不引起任何的 I/O 操作。然后，该偏移量用于下一次的读或写操作。\n文件偏移量可以大于文件的当前长度，在这种情况下，对于文件的下一次写操作将会加长该文件，并在文件中造成一个空洞，这一点是允许的。位于文件中但没有写过的字节被读为 0。文件的空洞并不要求在磁盘上占用存储区。具体处理方式与文件系统的实现有关，当定位到超出文件尾端之后写时，对于新写的数据需要分配磁盘块，但是对于原文件尾端和新开始写位置之间的部分则不需要分配磁盘块。\n文件空洞示例： 因为 lseek 使用的偏移量是用 off_t 类型表示的，所以允许具体实现根据各自特定的平台自行选择大小合适的数据类型。现今大多数平台提供两组接口以处理文件偏移量。一组使用 32 位文件偏移量，另一组使用 64 位文件偏移量。\n注意：尽管可以实现 64 位文件偏移量，但是能否创建一个大于 2GB（$2^{31}$ - 1 字节）的文件则依赖于底层文件系统的类型。\n六、函数 read 1 2 3 4 5 #include \u0026lt;unistd.h\u0026gt; ssize_t read(int fd, void *buf, size_t nbytes); 返回值：读到的字节数，若已到文件尾，返回 0；若出错，返回 -1 有多种情况可使实际读到的字节数少于要求读的字节数：\n读普通文件时，在读到要求字节数之前已经到达了文件尾端。 当从终端设备读时，通常一次最多读一行。 当从网络读时，网络中的缓冲机制可能造成返回值小于所要求读的字节数。 当从管道或 FIFO 读时，如若管道包含的字节少于所需的数量，那么 read 将只返回实际可用的字节数。 当从某些面向记录的设备（如磁带）读时，一次最多返回一个记录。 当一信号造成中断，而已经读了部分数据量时。 读操作从文件的当前偏移量开始，在成功返回之前，该偏移量将增加实际读到的字节数。\n七、函数 write 1 2 3 4 5 #include \u0026lt;unistd.h\u0026gt; ssize_t write(int fd, const void *buf, size_t nbytes); 返回值：若成功，返回已写的字节数；若出错，返回 -1 其返回值通常与参数 nbytes 的值相同，否则表示出错。write 出错的一个常见原因是磁盘写满，或者是超过了一个给定进程的文件长度限制。\n对于普通文件，写操作从文件的当前偏移量开始。如果在打开文件时，指定了 O_APPEND 选项，则在每次写操作之前，将文件偏移量设置在文件的当前结尾处。在一次写操作成功后，该文件偏移量增加实际写的字节数。\n八、I/O 的效率 下图显示了用 20 种不同的缓冲区长度，读 516 581 760 字节的文件所得到的结果。 此测试所用的文件系统是 Linux ext4 文件系统，其磁盘块长度为 4 096 字节，图中 CPU 时间的几个最小值差不多出现在 BUFFSIZE 为 4 096 及以后得位置，继续增加缓冲区长度对此时间几乎没有影响。\n大多数文件系统为改善性能都采用某种 预读（read ahead） 技术。当检测到正进行顺序读取时，系统就试图读入比应用要求的更多数据，并假想应用很快就会读这些数据。从图中可以看出，缓冲区长度小至 32 字节时的时钟时间与拥有较大缓冲区长度时的时钟时间几乎一样。（局部性原理）\n九、文件共享 UNIX 系统支持在不同进程间共享打开文件。内核使用了 3 种数据结构表示打开文件，它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响。\n每个进程在进程表中都有一个记录项，记录项中包含一张打开文件描述符表，每个描述符表占用一项。与每个文件描述符关联的是： 文件描述符标志。 指向一个文件表项的指针。 内核为所有打开文件维护一张文件表，每个文件表项包含： 文件状态标志（读、写、添写、同步和非阻塞等） 当前文件偏移量。 指向该文件 v 节点表项的指针。 每个打开文件（或设备）都有一个 v 节点（v-node） 结构。v 节点包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件，v 节点还包含了该文件的 i 节点（i-node，索引节点）。这些信息是在打开文件时从磁盘读入内存的，所以，文件的所有相关信息都是随时可用的。 Linux 没有使用 v 节点，而是采用了一个与文件系统相关的 i 节点和一个与文件系统无关的 i 节点。\n下图展示了一个进程打开多个文件的情况： 下图展示了多个进程打开同一文件的情况： 打开该文件的每个进程都获得各自的一个文件表项，但对一个给定的文件只有一个 v 节点表项。之所以每个进程都获得自己的文件表项，是因为这可以使每个进程都有它自己的对该文件的当前偏移量。\n注意，文件描述符标志和文件状态标志在作用范围方面的区别，前者只用于一个进程的一个描述符，而后者则应用于指向该给定文件表项的任何进程中的所有描述符。\n十、原子操作 一般而言，原子操作（atomic operation） 指的是由多步组成的一个操作。如果该操作原子的执行，则要么执行完所有步骤，要么 一步也不执行，不可能只执行所有步骤中的一个子集。任何要求多于一个函数调用的操作都不是原子操作，因为在两个函数调用之间，内核有可能会临时挂起进程。\n函数 pread 和 pwrite 1 2 3 4 5 6 7 8 9 #include \u0026lt;unistd.h\u0026gt; ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset); 返回值：读到的字节数，若已到文件尾，返回 0；若出错，返回 -1 ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset); 返回值：若成功，返回已写的字节数；若出错，返回 -1 调用 pread 相当于调用 lseek 后调用 read，但是 pread 又与这种顺序调用有下列重要区别：\n调用 pread 时，无法终端其定位和读操作。 不更新当前文件偏移量。 调用 pwrite 相当于调用 lseek 后调用 write，但也与它们有类似区别。\n十一、函数 dup 和 dup2 下面两个函数都可以用来复制一个现有的文件描述符：\ndup == duplicate 复制\n1 2 3 4 5 6 7 #include \u0026lt;unistd.h\u0026gt; int dup(int fd); int dup2(int fd, int fd2); 两函数的返回值：若成功，返回新的文件描述符；若出错，返回 -1 由 dup 返回的新描述符一定是当前可用文件描述符中的最小值（open 和 openat 同样返回当前可用文件描述符中的最小值）。对于 dup2，可以用 fd2 参数指定新的描述符值。如果 fd2 已经打开，则先将其关闭。如果 fd2 等于 fd，则 dup2 返回 fd2，然后并不关闭它。否则，fd2 的 FDCLOEXEC 文件描述符标志就被清除，这样 _fd2 在进程调用 exec 时是打开状态。\n下图展示了 dup(1) 之后的情况： 十二、函数 sync、fsync 和 fdatasync 传统的 UNIX 系统实现在内核中设有缓冲区高速缓存或页高速缓存，大多数磁盘 I/O 都通过缓冲区进行。当我们向文件写入数据时，内核通常先将数据复制到缓冲区中，然后排入队列，晚些时候再写入磁盘。这种方式被称为 延迟写（delayed write）。\n通常，当内核需要重用缓冲区来存放其他磁盘块数据时，它会把所有延迟写数据写入磁盘，为了保证磁盘上实际文件系统与缓冲区内容的一致性，UNIX 系统提供了 sync、fsync 和 fdatasync 三个函数。\n1 2 3 4 5 6 7 8 9 #include \u0026lt;unistd.h\u0026gt; int fsync(int fd); int fdatasync(int fd); 返回值：若成功，返回 0；若出错，返回 -1 void sync(void); sync：只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。\nfsync：只对由文件描述符 fd 指定的一个文件起作用，并且等待写磁盘操作结束才返回。\nfdatasync：类似于 fsync，但它只影响文件的数据部分。而除数据外，fsync 还会同步更新文件的属性。\n十三、函数 fcntl fcntl 函数可以改变已经打开文件的属性。\n1 2 3 4 5 #include \u0026lt;fcntl.h\u0026gt; int fcntl(int fd, int cmd, ... /* int arg */); 返回值：若成功，则依赖于 cmd；若出错，返回 -1 根据 cmd 参数的不同，fcntl 函数有以下 5 种功能：\n复制一个已有的描述符（cmd = F_DUPFD 或 F_DUPFD_CLOEXEC）。 获取/设置文件描述符标志（cmd = F_GETFD 或 F_SETFD）。 获取/设置文件状态标志（cmd = F_GETFL 或 F_SETFL）。 获取/设置异步 I/O 所有权（cmd = F_GETOWN 或 F_SETOWN）。 获取/设置记录锁（cmd = F_GETLK、F_SETLK 或 F_SETLKW）。 十四、函数 ioctl 不能用本章其他函数表示的 I/O 操作都可以用 ioctl 函数表示，终端 I/O 是使用 ioctl 函数最多的地方。\n1 2 3 4 5 6 7 #include \u0026lt;unistd.h\u0026gt; /* System V */ #include \u0026lt;sys/ioctl.h\u0026gt; /* BSD and Linux */ int ioctl(int fd, int request, ...); 返回值：若出错，返回 -1；若成功，返回其他值 十五、/dev/fd 较新的系统中都提供了 /dev/fd 目录，打开文件 /dev/fd/n 相当于复制描述符 n，前提是描述符 n 是打开的。\n","date":"2023-02-09T15:18:07+08:00","image":"https://www.imxiejie.me/p/%E6%96%87%E4%BB%B6-i/o/unix-book_hu4547a7503b7987387e6e836bc31e69b7_54147_120x120_fill_q75_box_smart1.jpeg","permalink":"https://www.imxiejie.me/p/%E6%96%87%E4%BB%B6-i/o/","title":"文件 I/O"},{"content":"一、UNIX 体系结构 严格意义上说，可以将操作系统定义为一种软件，它控制着计算机硬件资源，提供程序运行环境，通常将这种软件称为 内核（kernel），因为它相对较小，而且位于环境的核心。\n内核的接口称为 系统调用（system call），公用函数库 建立在系统调用之上，应用程序既可以使用公用函数库，也可以使用系统调用。\nshell 是一个特殊的应用程序，其为运行其他应用程序提供了一个接口。\n二、登录 用户登录 UNIX 系统时，先键入登录名，后键入口令。系统在其口令文件（通常为/etc/passwd）查看登录名。\nroot:x:0:0:root:/root:/bin/bash\n口令中间中的登录项由 7 个以冒号分割的字段组成，依次是：登录名（root）、加密口令（x）、用户 ID（UID 0）、用户组 ID（GID 0）、注释字段（root）、起始目录（/root）以及 shell 程序（/bin/bash）。\n三、文件和目录 1. 文件系统 UNIX 文件系统是目录和文件的一种层次结构，所有东西的起点都是称为 根（root） 的目录，这个目录的名称是一个字符 / 。\n目录（directory） 是一个包含目录项的文件。在逻辑上，可以认为每个目录项都包含一个文件名，同时还包含说明该文件属性的信息。文件属性是指文件类型（是普通文件还是目录等）、文件大小、文件所有者、文件权限（其他用户能否访问该文件）以及文件最后的修改时间等。\n2. 文件名 目录中各个名字称为 文件名（filename）。只有 斜线（/） 和 空字符 这两个字符不能出现在文件名中。斜线用来分隔构成路径名的各文件名，空字符用来终止一个路径名。\n创建新目录时会自动创建两个文件名：.（称为点） 和 ..（称为点点）。点指向当前目录，点点指向父目录。在最高层次的根目录中，点和点点没有区别。\n3. 路径名 路径名（pathname） 是由一个或多个文件名组成的序列，文件名之间用斜线分隔。如：/usr/local/include。\n以斜线开头的路径名称为 绝对路径（absolute pathname），否则称为 相对路径（relative pathname）。相对路径指向相对于当前目录的文件。文件系统根的名字 / 是一个特殊的绝对路径名，它不包含文件名。\n4. 工作目录 每个进程都有一个 工作目录（working directory），所有的相对路径名都从工作目录开始解释。\n5. 起始目录 在登录时，工作目录被设置为 起始目录（home directory），可从口令文件中获得。\n四、输入和输出 1. 文件描述符 文件描述符（file descriptor） 通常是一个小的非负整数，内核用以标识一个特定进程正在访问的文件。当内核创建一个新文件或打开一个现有文件，都将返回一个文件描述符。在进行读、写操作时，都可以使用和这个文件描述符。\n2. 标准输入、标准输出和标准错误 按惯例，每当运行一个新程序时，所有的 shell 都会为其打开 3 个文件描述符，分别是 标准输入（standard input）、标准输出（standard output） 和 标准错误（standard error），相对应的描述符 ID 分别为 0、1、2。如果不做特殊处理，则这 3 个描述符都链接向终端。\n3. 不带缓冲的 I/O 函数 open、read、write、lseek 以及 close 提供了不带缓冲的 I/O，这些函数都使用文件描述符。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 从标准输入读，并向标准输出写 #include \u0026#34;apue.h\u0026#34; #define BUFFSIZE 4096 int main(void) { int n; char buf[BUFFSIZE]; while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) \u0026gt; 0) { if (write(STDOUT_FILENO, buf, n) != n) { err_sys(\u0026#34;write error\u0026#34;); } } if (n \u0026lt; 0) { err_sys(\u0026#34;read error\u0026#34;); } exit(0); } 4. 标准 I/O 标准 I/O 函数为那些不带缓冲的 I/O 函数提供了一个带缓冲的接口。\n五、程序和进程 1. 程序 程序（program） 是一个存储在磁盘上某个目录的可执行文件。\n2. 进程和进程 ID 进程（process） 是指程序的执行实例，每个进程都有一个唯一的非负整数作为其 进程 ID。\n3. 进程控制 有 3 个主要用于进程控制的函数，分别为 fork、exec 和 waitpid。\n4. 线程和线程 ID 线程（thread） 是操作系统能够进行运算调度的最小单位。通常，一个进程只有一个控制线程\u0026mdash;某一时刻执行的一组机器指令。一个进程内的所有线程共享同一地址空间、文件描述符、栈以及进程相关的属性。\n同进程相同，线程也用 ID 标识。但是，线程 ID 只在其所在的进程内有意义，在另一个进程中没有意义。\n六、出错处理 当 UNIX 系统函数出错时，通常会返回一个负值，而且整形变量 errno 通常被设置为具有特定信息的值。在支持线程的环境中，多个线程共享进程地址空间，每个线程都有其局部的 errno 值，以避免一个线程干扰另一个线程。\n对于 errno 应注意两条规则。第一条规则是：如果没有出错，其值不会被例程清除。因此，仅当函数返回错误时，才检验其值。第二条规则是：任何函数都不会将 errno 设置为 0，而且在 \u0026lt;errno.h\u0026gt; 中定义的常量都不为 0。\n可将在 \u0026lt;errno.h\u0026gt; 中定义的错误分为两类：致命性的和非致命性的。对于致命性的错误，无法恢复，最多只能打印一条错误信息。对于非致命性的错误，有时可以妥善处理。\n七、用户标识 1. 用户 ID 口令文件登录项中的 用户 ID（user ID） 是一个整数值，它向系统标识各个不同的用户。系统管理员在确定一个用户的登录名的同时，确定其用户 ID。用户不能更改其用户 ID。用户 ID 为 0 的用户称为 根用户（root） 或 超级用户（superuser）。\n2. 组 ID 口令文件登录项中还包含了用户的 组 ID（group ID），组 ID 也是由系统管理员在指定用户登录名分配的。多个用户可划分在同一个组 ID，这可以使同组的成员之间共享资源（如文件）。\n组文件将组名映射为数值的组 ID，组文件通常是 /etc/group。\n3. 附属组 ID 大多数 UNIX 系统版本还允许一个用户属于另外一些组。登录时，读取文件/etc/group，寻找列有该用户作为其成员的前 16 个记录项就可以得到该用户的 附属组 ID（supplementary group ID）。\n八、信号 信号（signal） 用于通知进程发生了某种情况。进程有以下 3 种处理信号的方式。\n忽略信号。有些异常产生的后果不确定，不推荐使用这种处理方式。 按系统默认方式处理。 提供一个函数，信号发生时调用该函数，这称为捕捉该信号。 当向一个进程发送信号时，我们必须是那个进程的所有者或者是超级用户。\n九、时间值 历史上，UNIX 使用过两种不同的时间值。\n日历时间，该值是自 协调世界时（Coordinated Universal Time，UTC） 1970 年 1 月 1 日 00:00:00 这个特定时间以为所经过的秒数。\n系统基本数据类型 time_t 用于保存这种时间值。 进程时间，也被称为 CPU 时间，用以度量进程使用的中央处理器资源。进程时间以时钟滴答计算，每秒钟曾取为 50、60 或 100 个时钟滴答。\n系统基本类型 clock_t 用于保存这种时间值。 UNIX 系统为一个进程维护了 3 个进程时间值：\n时钟时间 用户 CPU 时间 系统 CPU 时间 时钟时间 又称为 墙上时钟时间（wall clock time），它是进程运行的时间总量，其值与系统中同时运行的进程数量有关。\n用户 CPU 时间 是指执行用户指令所用的时间量。\n系统 CPU 时间 是指为该进程执行内核程序所用的时间量。\n十、系统调用和库函数 应用程序既可以调用系统调用也可以调用库函数。很多库函数则会调用系统调用。\n系统调用和库函数之间的一个差别是：系统调用通常提供一种最小接口，而库函数通常提供比较复杂的功能。\n","date":"2023-02-08T16:57:53+08:00","image":"https://www.imxiejie.me/p/unix-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/unix-book_hu4547a7503b7987387e6e836bc31e69b7_54147_120x120_fill_q75_box_smart1.jpeg","permalink":"https://www.imxiejie.me/p/unix-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"UNIX 基础知识"}]